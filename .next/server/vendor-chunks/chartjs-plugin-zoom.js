"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/chartjs-plugin-zoom";
exports.ids = ["vendor-chunks/chartjs-plugin-zoom"];
exports.modules = {

/***/ "(ssr)/./node_modules/chartjs-plugin-zoom/dist/chartjs-plugin-zoom.esm.js":
/*!**************************************************************************!*\
  !*** ./node_modules/chartjs-plugin-zoom/dist/chartjs-plugin-zoom.esm.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ plugin),\n/* harmony export */   pan: () => (/* binding */ pan),\n/* harmony export */   resetZoom: () => (/* binding */ resetZoom),\n/* harmony export */   zoom: () => (/* binding */ zoom),\n/* harmony export */   zoomRect: () => (/* binding */ zoomRect),\n/* harmony export */   zoomScale: () => (/* binding */ zoomScale)\n/* harmony export */ });\n/* harmony import */ var hammerjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! hammerjs */ \"(ssr)/./node_modules/hammerjs/hammer.js\");\n/* harmony import */ var hammerjs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(hammerjs__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! chart.js/helpers */ \"(ssr)/./node_modules/chart.js/helpers/helpers.js\");\n/*!\n* chartjs-plugin-zoom v2.1.0\n* https://www.chartjs.org/chartjs-plugin-zoom/2.1.0/\n * (c) 2016-2024 chartjs-plugin-zoom Contributors\n * Released under the MIT License\n */\n\n\n\nconst getModifierKey = opts => opts && opts.enabled && opts.modifierKey;\nconst keyPressed = (key, event) => key && event[key + 'Key'];\nconst keyNotPressed = (key, event) => key && !event[key + 'Key'];\nfunction directionEnabled(mode, dir, chart) {\n  if (mode === undefined) {\n    return true;\n  } else if (typeof mode === 'string') {\n    return mode.indexOf(dir) !== -1;\n  } else if (typeof mode === 'function') {\n    return mode({chart}).indexOf(dir) !== -1;\n  }\n  return false;\n}\nfunction directionsEnabled(mode, chart) {\n  if (typeof mode === 'function') {\n    mode = mode({chart});\n  }\n  if (typeof mode === 'string') {\n    return {x: mode.indexOf('x') !== -1, y: mode.indexOf('y') !== -1};\n  }\n  return {x: false, y: false};\n}\nfunction debounce(fn, delay) {\n  let timeout;\n  return function() {\n    clearTimeout(timeout);\n    timeout = setTimeout(fn, delay);\n    return delay;\n  };\n}\nfunction getScaleUnderPoint({x, y}, chart) {\n  const scales = chart.scales;\n  const scaleIds = Object.keys(scales);\n  for (let i = 0; i < scaleIds.length; i++) {\n    const scale = scales[scaleIds[i]];\n    if (y >= scale.top && y <= scale.bottom && x >= scale.left && x <= scale.right) {\n      return scale;\n    }\n  }\n  return null;\n}\nfunction getEnabledScalesByPoint(options, point, chart) {\n  const {mode = 'xy', scaleMode, overScaleMode} = options || {};\n  const scale = getScaleUnderPoint(point, chart);\n  const enabled = directionsEnabled(mode, chart);\n  const scaleEnabled = directionsEnabled(scaleMode, chart);\n  if (overScaleMode) {\n    const overScaleEnabled = directionsEnabled(overScaleMode, chart);\n    for (const axis of ['x', 'y']) {\n      if (overScaleEnabled[axis]) {\n        scaleEnabled[axis] = enabled[axis];\n        enabled[axis] = false;\n      }\n    }\n  }\n  if (scale && scaleEnabled[scale.axis]) {\n    return [scale];\n  }\n  const enabledScales = [];\n  (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.each)(chart.scales, function(scaleItem) {\n    if (enabled[scaleItem.axis]) {\n      enabledScales.push(scaleItem);\n    }\n  });\n  return enabledScales;\n}\n\nconst chartStates = new WeakMap();\nfunction getState(chart) {\n  let state = chartStates.get(chart);\n  if (!state) {\n    state = {\n      originalScaleLimits: {},\n      updatedScaleLimits: {},\n      handlers: {},\n      panDelta: {},\n      dragging: false,\n      panning: false\n    };\n    chartStates.set(chart, state);\n  }\n  return state;\n}\nfunction removeState(chart) {\n  chartStates.delete(chart);\n}\n\nfunction zoomDelta(val, min, range, newRange) {\n  const minPercent = Math.max(0, Math.min(1, (val - min) / range || 0));\n  const maxPercent = 1 - minPercent;\n  return {\n    min: newRange * minPercent,\n    max: newRange * maxPercent\n  };\n}\nfunction getValueAtPoint(scale, point) {\n  const pixel = scale.isHorizontal() ? point.x : point.y;\n  return scale.getValueForPixel(pixel);\n}\nfunction linearZoomDelta(scale, zoom, center) {\n  const range = scale.max - scale.min;\n  const newRange = range * (zoom - 1);\n  const centerValue = getValueAtPoint(scale, center);\n  return zoomDelta(centerValue, scale.min, range, newRange);\n}\nfunction logarithmicZoomRange(scale, zoom, center) {\n  const centerValue = getValueAtPoint(scale, center);\n  if (centerValue === undefined) {\n    return {min: scale.min, max: scale.max};\n  }\n  const logMin = Math.log10(scale.min);\n  const logMax = Math.log10(scale.max);\n  const logCenter = Math.log10(centerValue);\n  const logRange = logMax - logMin;\n  const newLogRange = logRange * (zoom - 1);\n  const delta = zoomDelta(logCenter, logMin, logRange, newLogRange);\n  return {\n    min: Math.pow(10, logMin + delta.min),\n    max: Math.pow(10, logMax - delta.max),\n  };\n}\nfunction getScaleLimits(scale, limits) {\n  return limits && (limits[scale.id] || limits[scale.axis]) || {};\n}\nfunction getLimit(state, scale, scaleLimits, prop, fallback) {\n  let limit = scaleLimits[prop];\n  if (limit === 'original') {\n    const original = state.originalScaleLimits[scale.id][prop];\n    limit = (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.valueOrDefault)(original.options, original.scale);\n  }\n  return (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.valueOrDefault)(limit, fallback);\n}\nfunction linearRange(scale, pixel0, pixel1) {\n  const v0 = scale.getValueForPixel(pixel0);\n  const v1 = scale.getValueForPixel(pixel1);\n  return {\n    min: Math.min(v0, v1),\n    max: Math.max(v0, v1)\n  };\n}\nfunction fixRange(range, {min, max, minLimit, maxLimit}, originalLimits) {\n  const offset = (range - max + min) / 2;\n  min -= offset;\n  max += offset;\n  const origMin = originalLimits.min.options ?? originalLimits.min.scale;\n  const origMax = originalLimits.max.options ?? originalLimits.max.scale;\n  const epsilon = range / 1e6;\n  if ((0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.almostEquals)(min, origMin, epsilon)) {\n    min = origMin;\n  }\n  if ((0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.almostEquals)(max, origMax, epsilon)) {\n    max = origMax;\n  }\n  if (min < minLimit) {\n    min = minLimit;\n    max = Math.min(minLimit + range, maxLimit);\n  } else if (max > maxLimit) {\n    max = maxLimit;\n    min = Math.max(maxLimit - range, minLimit);\n  }\n  return {min, max};\n}\nfunction updateRange(scale, {min, max}, limits, zoom = false) {\n  const state = getState(scale.chart);\n  const {options: scaleOpts} = scale;\n  const scaleLimits = getScaleLimits(scale, limits);\n  const {minRange = 0} = scaleLimits;\n  const minLimit = getLimit(state, scale, scaleLimits, 'min', -Infinity);\n  const maxLimit = getLimit(state, scale, scaleLimits, 'max', Infinity);\n  if (zoom === 'pan' && (min < minLimit || max > maxLimit)) {\n    return true;\n  }\n  const scaleRange = scale.max - scale.min;\n  const range = zoom ? Math.max(max - min, minRange) : scaleRange;\n  if (zoom && range === minRange && scaleRange <= minRange) {\n    return true;\n  }\n  const newRange = fixRange(range, {min, max, minLimit, maxLimit}, state.originalScaleLimits[scale.id]);\n  scaleOpts.min = newRange.min;\n  scaleOpts.max = newRange.max;\n  state.updatedScaleLimits[scale.id] = newRange;\n  return scale.parse(newRange.min) !== scale.min || scale.parse(newRange.max) !== scale.max;\n}\nfunction zoomNumericalScale(scale, zoom, center, limits) {\n  const delta = linearZoomDelta(scale, zoom, center);\n  const newRange = {min: scale.min + delta.min, max: scale.max - delta.max};\n  return updateRange(scale, newRange, limits, true);\n}\nfunction zoomLogarithmicScale(scale, zoom, center, limits) {\n  const newRange = logarithmicZoomRange(scale, zoom, center);\n  return updateRange(scale, newRange, limits, true);\n}\nfunction zoomRectNumericalScale(scale, from, to, limits) {\n  updateRange(scale, linearRange(scale, from, to), limits, true);\n}\nconst integerChange = (v) => v === 0 || isNaN(v) ? 0 : v < 0 ? Math.min(Math.round(v), -1) : Math.max(Math.round(v), 1);\nfunction existCategoryFromMaxZoom(scale) {\n  const labels = scale.getLabels();\n  const maxIndex = labels.length - 1;\n  if (scale.min > 0) {\n    scale.min -= 1;\n  }\n  if (scale.max < maxIndex) {\n    scale.max += 1;\n  }\n}\nfunction zoomCategoryScale(scale, zoom, center, limits) {\n  const delta = linearZoomDelta(scale, zoom, center);\n  if (scale.min === scale.max && zoom < 1) {\n    existCategoryFromMaxZoom(scale);\n  }\n  const newRange = {min: scale.min + integerChange(delta.min), max: scale.max - integerChange(delta.max)};\n  return updateRange(scale, newRange, limits, true);\n}\nfunction scaleLength(scale) {\n  return scale.isHorizontal() ? scale.width : scale.height;\n}\nfunction panCategoryScale(scale, delta, limits) {\n  const labels = scale.getLabels();\n  const lastLabelIndex = labels.length - 1;\n  let {min, max} = scale;\n  const range = Math.max(max - min, 1);\n  const stepDelta = Math.round(scaleLength(scale) / Math.max(range, 10));\n  const stepSize = Math.round(Math.abs(delta / stepDelta));\n  let applied;\n  if (delta < -stepDelta) {\n    max = Math.min(max + stepSize, lastLabelIndex);\n    min = range === 1 ? max : max - range;\n    applied = max === lastLabelIndex;\n  } else if (delta > stepDelta) {\n    min = Math.max(0, min - stepSize);\n    max = range === 1 ? min : min + range;\n    applied = min === 0;\n  }\n  return updateRange(scale, {min, max}, limits) || applied;\n}\nconst OFFSETS = {\n  second: 500,\n  minute: 30 * 1000,\n  hour: 30 * 60 * 1000,\n  day: 12 * 60 * 60 * 1000,\n  week: 3.5 * 24 * 60 * 60 * 1000,\n  month: 15 * 24 * 60 * 60 * 1000,\n  quarter: 60 * 24 * 60 * 60 * 1000,\n  year: 182 * 24 * 60 * 60 * 1000\n};\nfunction panNumericalScale(scale, delta, limits, pan = false) {\n  const {min: prevStart, max: prevEnd, options} = scale;\n  const round = options.time && options.time.round;\n  const offset = OFFSETS[round] || 0;\n  const newMin = scale.getValueForPixel(scale.getPixelForValue(prevStart + offset) - delta);\n  const newMax = scale.getValueForPixel(scale.getPixelForValue(prevEnd + offset) - delta);\n  if (isNaN(newMin) || isNaN(newMax)) {\n    return true;\n  }\n  return updateRange(scale, {min: newMin, max: newMax}, limits, pan ? 'pan' : false);\n}\nfunction panNonLinearScale(scale, delta, limits) {\n  return panNumericalScale(scale, delta, limits, true);\n}\nconst zoomFunctions = {\n  category: zoomCategoryScale,\n  default: zoomNumericalScale,\n  logarithmic: zoomLogarithmicScale,\n};\nconst zoomRectFunctions = {\n  default: zoomRectNumericalScale,\n};\nconst panFunctions = {\n  category: panCategoryScale,\n  default: panNumericalScale,\n  logarithmic: panNonLinearScale,\n  timeseries: panNonLinearScale,\n};\n\nfunction shouldUpdateScaleLimits(scale, originalScaleLimits, updatedScaleLimits) {\n  const {id, options: {min, max}} = scale;\n  if (!originalScaleLimits[id] || !updatedScaleLimits[id]) {\n    return true;\n  }\n  const previous = updatedScaleLimits[id];\n  return previous.min !== min || previous.max !== max;\n}\nfunction removeMissingScales(limits, scales) {\n  (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.each)(limits, (opt, key) => {\n    if (!scales[key]) {\n      delete limits[key];\n    }\n  });\n}\nfunction storeOriginalScaleLimits(chart, state) {\n  const {scales} = chart;\n  const {originalScaleLimits, updatedScaleLimits} = state;\n  (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.each)(scales, function(scale) {\n    if (shouldUpdateScaleLimits(scale, originalScaleLimits, updatedScaleLimits)) {\n      originalScaleLimits[scale.id] = {\n        min: {scale: scale.min, options: scale.options.min},\n        max: {scale: scale.max, options: scale.options.max},\n      };\n    }\n  });\n  removeMissingScales(originalScaleLimits, scales);\n  removeMissingScales(updatedScaleLimits, scales);\n  return originalScaleLimits;\n}\nfunction doZoom(scale, amount, center, limits) {\n  const fn = zoomFunctions[scale.type] || zoomFunctions.default;\n  (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.callback)(fn, [scale, amount, center, limits]);\n}\nfunction doZoomRect(scale, from, to, limits) {\n  const fn = zoomRectFunctions[scale.type] || zoomRectFunctions.default;\n  (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.callback)(fn, [scale, from, to, limits]);\n}\nfunction getCenter(chart) {\n  const ca = chart.chartArea;\n  return {\n    x: (ca.left + ca.right) / 2,\n    y: (ca.top + ca.bottom) / 2,\n  };\n}\nfunction zoom(chart, amount, transition = 'none') {\n  const {x = 1, y = 1, focalPoint = getCenter(chart)} = typeof amount === 'number' ? {x: amount, y: amount} : amount;\n  const state = getState(chart);\n  const {options: {limits, zoom: zoomOptions}} = state;\n  storeOriginalScaleLimits(chart, state);\n  const xEnabled = x !== 1;\n  const yEnabled = y !== 1;\n  const enabledScales = getEnabledScalesByPoint(zoomOptions, focalPoint, chart);\n  (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.each)(enabledScales || chart.scales, function(scale) {\n    if (scale.isHorizontal() && xEnabled) {\n      doZoom(scale, x, focalPoint, limits);\n    } else if (!scale.isHorizontal() && yEnabled) {\n      doZoom(scale, y, focalPoint, limits);\n    }\n  });\n  chart.update(transition);\n  (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.callback)(zoomOptions.onZoom, [{chart}]);\n}\nfunction zoomRect(chart, p0, p1, transition = 'none') {\n  const state = getState(chart);\n  const {options: {limits, zoom: zoomOptions}} = state;\n  const {mode = 'xy'} = zoomOptions;\n  storeOriginalScaleLimits(chart, state);\n  const xEnabled = directionEnabled(mode, 'x', chart);\n  const yEnabled = directionEnabled(mode, 'y', chart);\n  (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.each)(chart.scales, function(scale) {\n    if (scale.isHorizontal() && xEnabled) {\n      doZoomRect(scale, p0.x, p1.x, limits);\n    } else if (!scale.isHorizontal() && yEnabled) {\n      doZoomRect(scale, p0.y, p1.y, limits);\n    }\n  });\n  chart.update(transition);\n  (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.callback)(zoomOptions.onZoom, [{chart}]);\n}\nfunction zoomScale(chart, scaleId, range, transition = 'none') {\n  const state = getState(chart);\n  storeOriginalScaleLimits(chart, state);\n  const scale = chart.scales[scaleId];\n  updateRange(scale, range, undefined, true);\n  chart.update(transition);\n  (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.callback)(state.options.zoom?.onZoom, [{chart}]);\n}\nfunction resetZoom(chart, transition = 'default') {\n  const state = getState(chart);\n  const originalScaleLimits = storeOriginalScaleLimits(chart, state);\n  (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.each)(chart.scales, function(scale) {\n    const scaleOptions = scale.options;\n    if (originalScaleLimits[scale.id]) {\n      scaleOptions.min = originalScaleLimits[scale.id].min.options;\n      scaleOptions.max = originalScaleLimits[scale.id].max.options;\n    } else {\n      delete scaleOptions.min;\n      delete scaleOptions.max;\n    }\n    delete state.updatedScaleLimits[scale.id];\n  });\n  chart.update(transition);\n  (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.callback)(state.options.zoom.onZoomComplete, [{chart}]);\n}\nfunction getOriginalRange(state, scaleId) {\n  const original = state.originalScaleLimits[scaleId];\n  if (!original) {\n    return;\n  }\n  const {min, max} = original;\n  return (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.valueOrDefault)(max.options, max.scale) - (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.valueOrDefault)(min.options, min.scale);\n}\nfunction getZoomLevel(chart) {\n  const state = getState(chart);\n  let min = 1;\n  let max = 1;\n  (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.each)(chart.scales, function(scale) {\n    const origRange = getOriginalRange(state, scale.id);\n    if (origRange) {\n      const level = Math.round(origRange / (scale.max - scale.min) * 100) / 100;\n      min = Math.min(min, level);\n      max = Math.max(max, level);\n    }\n  });\n  return min < 1 ? min : max;\n}\nfunction panScale(scale, delta, limits, state) {\n  const {panDelta} = state;\n  const storedDelta = panDelta[scale.id] || 0;\n  if ((0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.sign)(storedDelta) === (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.sign)(delta)) {\n    delta += storedDelta;\n  }\n  const fn = panFunctions[scale.type] || panFunctions.default;\n  if ((0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.callback)(fn, [scale, delta, limits])) {\n    panDelta[scale.id] = 0;\n  } else {\n    panDelta[scale.id] = delta;\n  }\n}\nfunction pan(chart, delta, enabledScales, transition = 'none') {\n  const {x = 0, y = 0} = typeof delta === 'number' ? {x: delta, y: delta} : delta;\n  const state = getState(chart);\n  const {options: {pan: panOptions, limits}} = state;\n  const {onPan} = panOptions || {};\n  storeOriginalScaleLimits(chart, state);\n  const xEnabled = x !== 0;\n  const yEnabled = y !== 0;\n  (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.each)(enabledScales || chart.scales, function(scale) {\n    if (scale.isHorizontal() && xEnabled) {\n      panScale(scale, x, limits, state);\n    } else if (!scale.isHorizontal() && yEnabled) {\n      panScale(scale, y, limits, state);\n    }\n  });\n  chart.update(transition);\n  (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.callback)(onPan, [{chart}]);\n}\nfunction getInitialScaleBounds(chart) {\n  const state = getState(chart);\n  storeOriginalScaleLimits(chart, state);\n  const scaleBounds = {};\n  for (const scaleId of Object.keys(chart.scales)) {\n    const {min, max} = state.originalScaleLimits[scaleId] || {min: {}, max: {}};\n    scaleBounds[scaleId] = {min: min.scale, max: max.scale};\n  }\n  return scaleBounds;\n}\nfunction getZoomedScaleBounds(chart) {\n  const state = getState(chart);\n  const scaleBounds = {};\n  for (const scaleId of Object.keys(chart.scales)) {\n    scaleBounds[scaleId] = state.updatedScaleLimits[scaleId];\n  }\n  return scaleBounds;\n}\nfunction isZoomedOrPanned(chart) {\n  const scaleBounds = getInitialScaleBounds(chart);\n  for (const scaleId of Object.keys(chart.scales)) {\n    const {min: originalMin, max: originalMax} = scaleBounds[scaleId];\n    if (originalMin !== undefined && chart.scales[scaleId].min !== originalMin) {\n      return true;\n    }\n    if (originalMax !== undefined && chart.scales[scaleId].max !== originalMax) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction isZoomingOrPanning(chart) {\n  const state = getState(chart);\n  return state.panning || state.dragging;\n}\n\nfunction removeHandler(chart, type) {\n  const {handlers} = getState(chart);\n  const handler = handlers[type];\n  if (handler && handler.target) {\n    handler.target.removeEventListener(type, handler);\n    delete handlers[type];\n  }\n}\nfunction addHandler(chart, target, type, handler) {\n  const {handlers, options} = getState(chart);\n  const oldHandler = handlers[type];\n  if (oldHandler && oldHandler.target === target) {\n    return;\n  }\n  removeHandler(chart, type);\n  handlers[type] = (event) => handler(chart, event, options);\n  handlers[type].target = target;\n  const passive = type === 'wheel' ? false : undefined;\n  target.addEventListener(type, handlers[type], {passive});\n}\nfunction mouseMove(chart, event) {\n  const state = getState(chart);\n  if (state.dragStart) {\n    state.dragging = true;\n    state.dragEnd = event;\n    chart.update('none');\n  }\n}\nfunction keyDown(chart, event) {\n  const state = getState(chart);\n  if (!state.dragStart || event.key !== 'Escape') {\n    return;\n  }\n  removeHandler(chart, 'keydown');\n  state.dragging = false;\n  state.dragStart = state.dragEnd = null;\n  chart.update('none');\n}\nfunction getPointPosition(event, chart) {\n  const point = (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.getRelativePosition)(event, chart);\n  const canvasArea = chart.canvas.getBoundingClientRect();\n  if (!(0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__._isPointInArea)(event, canvasArea)) {\n    point.x = event.clientX - canvasArea.left;\n    point.y = event.clientY - canvasArea.top;\n  }\n  return point;\n}\nfunction zoomStart(chart, event, zoomOptions) {\n  const {onZoomStart, onZoomRejected} = zoomOptions;\n  if (onZoomStart) {\n    const point = getPointPosition(event, chart);\n    if ((0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.callback)(onZoomStart, [{chart, event, point}]) === false) {\n      (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.callback)(onZoomRejected, [{chart, event}]);\n      return false;\n    }\n  }\n}\nfunction mouseDown(chart, event) {\n  if (chart.legend) {\n    const point = (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.getRelativePosition)(event, chart);\n    if ((0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__._isPointInArea)(point, chart.legend)) {\n      return;\n    }\n  }\n  const state = getState(chart);\n  const {pan: panOptions, zoom: zoomOptions = {}} = state.options;\n  if (\n    event.button !== 0 ||\n    keyPressed(getModifierKey(panOptions), event) ||\n    keyNotPressed(getModifierKey(zoomOptions.drag), event)\n  ) {\n    return (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.callback)(zoomOptions.onZoomRejected, [{chart, event}]);\n  }\n  if (zoomStart(chart, event, zoomOptions) === false) {\n    return;\n  }\n  state.dragStart = event;\n  addHandler(chart, chart.canvas.ownerDocument, 'mousemove', mouseMove);\n  addHandler(chart, window.document, 'keydown', keyDown);\n}\nfunction applyAspectRatio(endPoint, beginPoint, aspectRatio) {\n  let width = endPoint.x - beginPoint.x;\n  let height = endPoint.y - beginPoint.y;\n  const ratio = Math.abs(width / height);\n  if (ratio > aspectRatio) {\n    width = Math.sign(width) * Math.abs(height * aspectRatio);\n  } else if (ratio < aspectRatio) {\n    height = Math.sign(height) * Math.abs(width / aspectRatio);\n  }\n  endPoint.x = beginPoint.x + width;\n  endPoint.y = beginPoint.y + height;\n}\nfunction applyMinMaxProps(rect, beginPoint, endPoint, {min, max, prop}) {\n  rect[min] = Math.max(0, Math.min(beginPoint[prop], endPoint[prop]));\n  rect[max] = Math.max(beginPoint[prop], endPoint[prop]);\n}\nfunction getReplativePoints(chart, points, maintainAspectRatio) {\n  const beginPoint = getPointPosition(points.dragStart, chart);\n  const endPoint = getPointPosition(points.dragEnd, chart);\n  if (maintainAspectRatio) {\n    const aspectRatio = chart.chartArea.width / chart.chartArea.height;\n    applyAspectRatio(endPoint, beginPoint, aspectRatio);\n  }\n  return {beginPoint, endPoint};\n}\nfunction computeDragRect(chart, mode, points, maintainAspectRatio) {\n  const xEnabled = directionEnabled(mode, 'x', chart);\n  const yEnabled = directionEnabled(mode, 'y', chart);\n  const {top, left, right, bottom, width: chartWidth, height: chartHeight} = chart.chartArea;\n  const rect = {top, left, right, bottom};\n  const {beginPoint, endPoint} = getReplativePoints(chart, points, maintainAspectRatio && xEnabled && yEnabled);\n  if (xEnabled) {\n    applyMinMaxProps(rect, beginPoint, endPoint, {min: 'left', max: 'right', prop: 'x'});\n  }\n  if (yEnabled) {\n    applyMinMaxProps(rect, beginPoint, endPoint, {min: 'top', max: 'bottom', prop: 'y'});\n  }\n  const width = rect.right - rect.left;\n  const height = rect.bottom - rect.top;\n  return {\n    ...rect,\n    width,\n    height,\n    zoomX: xEnabled && width ? 1 + ((chartWidth - width) / chartWidth) : 1,\n    zoomY: yEnabled && height ? 1 + ((chartHeight - height) / chartHeight) : 1\n  };\n}\nfunction mouseUp(chart, event) {\n  const state = getState(chart);\n  if (!state.dragStart) {\n    return;\n  }\n  removeHandler(chart, 'mousemove');\n  const {mode, onZoomComplete, drag: {threshold = 0, maintainAspectRatio}} = state.options.zoom;\n  const rect = computeDragRect(chart, mode, {dragStart: state.dragStart, dragEnd: event}, maintainAspectRatio);\n  const distanceX = directionEnabled(mode, 'x', chart) ? rect.width : 0;\n  const distanceY = directionEnabled(mode, 'y', chart) ? rect.height : 0;\n  const distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);\n  state.dragStart = state.dragEnd = null;\n  if (distance <= threshold) {\n    state.dragging = false;\n    chart.update('none');\n    return;\n  }\n  zoomRect(chart, {x: rect.left, y: rect.top}, {x: rect.right, y: rect.bottom}, 'zoom');\n  state.dragging = false;\n  state.filterNextClick = true;\n  (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.callback)(onZoomComplete, [{chart}]);\n}\nfunction wheelPreconditions(chart, event, zoomOptions) {\n  if (keyNotPressed(getModifierKey(zoomOptions.wheel), event)) {\n    (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.callback)(zoomOptions.onZoomRejected, [{chart, event}]);\n    return;\n  }\n  if (zoomStart(chart, event, zoomOptions) === false) {\n    return;\n  }\n  if (event.cancelable) {\n    event.preventDefault();\n  }\n  if (event.deltaY === undefined) {\n    return;\n  }\n  return true;\n}\nfunction wheel(chart, event) {\n  const {handlers: {onZoomComplete}, options: {zoom: zoomOptions}} = getState(chart);\n  if (!wheelPreconditions(chart, event, zoomOptions)) {\n    return;\n  }\n  const rect = event.target.getBoundingClientRect();\n  const speed = zoomOptions.wheel.speed;\n  const percentage = event.deltaY >= 0 ? 2 - 1 / (1 - speed) : 1 + speed;\n  const amount = {\n    x: percentage,\n    y: percentage,\n    focalPoint: {\n      x: event.clientX - rect.left,\n      y: event.clientY - rect.top\n    }\n  };\n  zoom(chart, amount);\n  (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.callback)(onZoomComplete, [{chart}]);\n}\nfunction addDebouncedHandler(chart, name, handler, delay) {\n  if (handler) {\n    getState(chart).handlers[name] = debounce(() => (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.callback)(handler, [{chart}]), delay);\n  }\n}\nfunction addListeners(chart, options) {\n  const canvas = chart.canvas;\n  const {wheel: wheelOptions, drag: dragOptions, onZoomComplete} = options.zoom;\n  if (wheelOptions.enabled) {\n    addHandler(chart, canvas, 'wheel', wheel);\n    addDebouncedHandler(chart, 'onZoomComplete', onZoomComplete, 250);\n  } else {\n    removeHandler(chart, 'wheel');\n  }\n  if (dragOptions.enabled) {\n    addHandler(chart, canvas, 'mousedown', mouseDown);\n    addHandler(chart, canvas.ownerDocument, 'mouseup', mouseUp);\n  } else {\n    removeHandler(chart, 'mousedown');\n    removeHandler(chart, 'mousemove');\n    removeHandler(chart, 'mouseup');\n    removeHandler(chart, 'keydown');\n  }\n}\nfunction removeListeners(chart) {\n  removeHandler(chart, 'mousedown');\n  removeHandler(chart, 'mousemove');\n  removeHandler(chart, 'mouseup');\n  removeHandler(chart, 'wheel');\n  removeHandler(chart, 'click');\n  removeHandler(chart, 'keydown');\n}\n\nfunction createEnabler(chart, state) {\n  return function(recognizer, event) {\n    const {pan: panOptions, zoom: zoomOptions = {}} = state.options;\n    if (!panOptions || !panOptions.enabled) {\n      return false;\n    }\n    const srcEvent = event && event.srcEvent;\n    if (!srcEvent) {\n      return true;\n    }\n    if (!state.panning && event.pointerType === 'mouse' && (\n      keyNotPressed(getModifierKey(panOptions), srcEvent) || keyPressed(getModifierKey(zoomOptions.drag), srcEvent))\n    ) {\n      (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.callback)(panOptions.onPanRejected, [{chart, event}]);\n      return false;\n    }\n    return true;\n  };\n}\nfunction pinchAxes(p0, p1) {\n  const pinchX = Math.abs(p0.clientX - p1.clientX);\n  const pinchY = Math.abs(p0.clientY - p1.clientY);\n  const p = pinchX / pinchY;\n  let x, y;\n  if (p > 0.3 && p < 1.7) {\n    x = y = true;\n  } else if (pinchX > pinchY) {\n    x = true;\n  } else {\n    y = true;\n  }\n  return {x, y};\n}\nfunction handlePinch(chart, state, e) {\n  if (state.scale) {\n    const {center, pointers} = e;\n    const zoomPercent = 1 / state.scale * e.scale;\n    const rect = e.target.getBoundingClientRect();\n    const pinch = pinchAxes(pointers[0], pointers[1]);\n    const mode = state.options.zoom.mode;\n    const amount = {\n      x: pinch.x && directionEnabled(mode, 'x', chart) ? zoomPercent : 1,\n      y: pinch.y && directionEnabled(mode, 'y', chart) ? zoomPercent : 1,\n      focalPoint: {\n        x: center.x - rect.left,\n        y: center.y - rect.top\n      }\n    };\n    zoom(chart, amount);\n    state.scale = e.scale;\n  }\n}\nfunction startPinch(chart, state, event) {\n  if (state.options.zoom.pinch.enabled) {\n    const point = (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.getRelativePosition)(event, chart);\n    (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.callback)(state.options.zoom.onZoomStart, [{chart, event, point}]);\n    state.scale = 1;\n  }\n}\nfunction endPinch(chart, state, e) {\n  if (state.scale) {\n    handlePinch(chart, state, e);\n    state.scale = null;\n    (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.callback)(state.options.zoom.onZoomComplete, [{chart}]);\n  }\n}\nfunction handlePan(chart, state, e) {\n  const delta = state.delta;\n  if (delta) {\n    state.panning = true;\n    pan(chart, {x: e.deltaX - delta.x, y: e.deltaY - delta.y}, state.panScales);\n    state.delta = {x: e.deltaX, y: e.deltaY};\n  }\n}\nfunction startPan(chart, state, event) {\n  const {enabled, onPanStart, onPanRejected} = state.options.pan;\n  if (!enabled) {\n    return;\n  }\n  const rect = event.target.getBoundingClientRect();\n  const point = {\n    x: event.center.x - rect.left,\n    y: event.center.y - rect.top\n  };\n  if ((0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.callback)(onPanStart, [{chart, event, point}]) === false) {\n    return (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.callback)(onPanRejected, [{chart, event}]);\n  }\n  state.panScales = getEnabledScalesByPoint(state.options.pan, point, chart);\n  state.delta = {x: 0, y: 0};\n  handlePan(chart, state, event);\n}\nfunction endPan(chart, state) {\n  state.delta = null;\n  if (state.panning) {\n    state.panning = false;\n    state.filterNextClick = true;\n    (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_1__.callback)(state.options.pan.onPanComplete, [{chart}]);\n  }\n}\nconst hammers = new WeakMap();\nfunction startHammer(chart, options) {\n  const state = getState(chart);\n  const canvas = chart.canvas;\n  const {pan: panOptions, zoom: zoomOptions} = options;\n  const mc = new (hammerjs__WEBPACK_IMPORTED_MODULE_0___default().Manager)(canvas);\n  if (zoomOptions && zoomOptions.pinch.enabled) {\n    mc.add(new (hammerjs__WEBPACK_IMPORTED_MODULE_0___default().Pinch)());\n    mc.on('pinchstart', (e) => startPinch(chart, state, e));\n    mc.on('pinch', (e) => handlePinch(chart, state, e));\n    mc.on('pinchend', (e) => endPinch(chart, state, e));\n  }\n  if (panOptions && panOptions.enabled) {\n    mc.add(new (hammerjs__WEBPACK_IMPORTED_MODULE_0___default().Pan)({\n      threshold: panOptions.threshold,\n      enable: createEnabler(chart, state)\n    }));\n    mc.on('panstart', (e) => startPan(chart, state, e));\n    mc.on('panmove', (e) => handlePan(chart, state, e));\n    mc.on('panend', () => endPan(chart, state));\n  }\n  hammers.set(chart, mc);\n}\nfunction stopHammer(chart) {\n  const mc = hammers.get(chart);\n  if (mc) {\n    mc.remove('pinchstart');\n    mc.remove('pinch');\n    mc.remove('pinchend');\n    mc.remove('panstart');\n    mc.remove('pan');\n    mc.remove('panend');\n    mc.destroy();\n    hammers.delete(chart);\n  }\n}\nfunction hammerOptionsChanged(oldOptions, newOptions) {\n  const {pan: oldPan, zoom: oldZoom} = oldOptions;\n  const {pan: newPan, zoom: newZoom} = newOptions;\n  if (oldZoom?.zoom?.pinch?.enabled !== newZoom?.zoom?.pinch?.enabled) {\n    return true;\n  }\n  if (oldPan?.enabled !== newPan?.enabled) {\n    return true;\n  }\n  if (oldPan?.threshold !== newPan?.threshold) {\n    return true;\n  }\n  return false;\n}\n\nvar version = \"2.1.0\";\n\nfunction draw(chart, caller, options) {\n  const dragOptions = options.zoom.drag;\n  const {dragStart, dragEnd} = getState(chart);\n  if (dragOptions.drawTime !== caller || !dragEnd) {\n    return;\n  }\n  const {left, top, width, height} = computeDragRect(chart, options.zoom.mode, {dragStart, dragEnd}, dragOptions.maintainAspectRatio);\n  const ctx = chart.ctx;\n  ctx.save();\n  ctx.beginPath();\n  ctx.fillStyle = dragOptions.backgroundColor || 'rgba(225,225,225,0.3)';\n  ctx.fillRect(left, top, width, height);\n  if (dragOptions.borderWidth > 0) {\n    ctx.lineWidth = dragOptions.borderWidth;\n    ctx.strokeStyle = dragOptions.borderColor || 'rgba(225,225,225)';\n    ctx.strokeRect(left, top, width, height);\n  }\n  ctx.restore();\n}\nvar plugin = {\n  id: 'zoom',\n  version,\n  defaults: {\n    pan: {\n      enabled: false,\n      mode: 'xy',\n      threshold: 10,\n      modifierKey: null,\n    },\n    zoom: {\n      wheel: {\n        enabled: false,\n        speed: 0.1,\n        modifierKey: null\n      },\n      drag: {\n        enabled: false,\n        drawTime: 'beforeDatasetsDraw',\n        modifierKey: null\n      },\n      pinch: {\n        enabled: false\n      },\n      mode: 'xy',\n    }\n  },\n  start: function(chart, _args, options) {\n    const state = getState(chart);\n    state.options = options;\n    if (Object.prototype.hasOwnProperty.call(options.zoom, 'enabled')) {\n      console.warn('The option `zoom.enabled` is no longer supported. Please use `zoom.wheel.enabled`, `zoom.drag.enabled`, or `zoom.pinch.enabled`.');\n    }\n    if (Object.prototype.hasOwnProperty.call(options.zoom, 'overScaleMode')\n      || Object.prototype.hasOwnProperty.call(options.pan, 'overScaleMode')) {\n      console.warn('The option `overScaleMode` is deprecated. Please use `scaleMode` instead (and update `mode` as desired).');\n    }\n    if ((hammerjs__WEBPACK_IMPORTED_MODULE_0___default())) {\n      startHammer(chart, options);\n    }\n    chart.pan = (delta, panScales, transition) => pan(chart, delta, panScales, transition);\n    chart.zoom = (args, transition) => zoom(chart, args, transition);\n    chart.zoomRect = (p0, p1, transition) => zoomRect(chart, p0, p1, transition);\n    chart.zoomScale = (id, range, transition) => zoomScale(chart, id, range, transition);\n    chart.resetZoom = (transition) => resetZoom(chart, transition);\n    chart.getZoomLevel = () => getZoomLevel(chart);\n    chart.getInitialScaleBounds = () => getInitialScaleBounds(chart);\n    chart.getZoomedScaleBounds = () => getZoomedScaleBounds(chart);\n    chart.isZoomedOrPanned = () => isZoomedOrPanned(chart);\n    chart.isZoomingOrPanning = () => isZoomingOrPanning(chart);\n  },\n  beforeEvent(chart, {event}) {\n    if (isZoomingOrPanning(chart)) {\n      return false;\n    }\n    if (event.type === 'click' || event.type === 'mouseup') {\n      const state = getState(chart);\n      if (state.filterNextClick) {\n        state.filterNextClick = false;\n        return false;\n      }\n    }\n  },\n  beforeUpdate: function(chart, args, options) {\n    const state = getState(chart);\n    const previousOptions = state.options;\n    state.options = options;\n    if (hammerOptionsChanged(previousOptions, options)) {\n      stopHammer(chart);\n      startHammer(chart, options);\n    }\n    addListeners(chart, options);\n  },\n  beforeDatasetsDraw(chart, _args, options) {\n    draw(chart, 'beforeDatasetsDraw', options);\n  },\n  afterDatasetsDraw(chart, _args, options) {\n    draw(chart, 'afterDatasetsDraw', options);\n  },\n  beforeDraw(chart, _args, options) {\n    draw(chart, 'beforeDraw', options);\n  },\n  afterDraw(chart, _args, options) {\n    draw(chart, 'afterDraw', options);\n  },\n  stop: function(chart) {\n    removeListeners(chart);\n    if ((hammerjs__WEBPACK_IMPORTED_MODULE_0___default())) {\n      stopHammer(chart);\n    }\n    removeState(chart);\n  },\n  panFunctions,\n  zoomFunctions,\n  zoomRectFunctions,\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2hhcnRqcy1wbHVnaW4tem9vbS9kaXN0L2NoYXJ0anMtcGx1Z2luLXpvb20uZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM4QjtBQUM2Rjs7QUFFM0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsTUFBTTtBQUN2QjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixLQUFLO0FBQ2xDO0FBQ0E7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHVDQUF1QztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsc0RBQUk7QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLDRCQUE0QjtBQUM1QixrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpREFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxzQkFBc0IsTUFBTTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsUUFBUSxpREFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFd0UiLCJzb3VyY2VzIjpbIkQ6XFxCaXRzIEh5ZGVyYWJhZFxcWWVhciAzIFNlbSAxXFxEZWVwIExlYXJuaW5nXFxQcm9qZWN0XFxmcm9udGVuZDJcXG5vZGVfbW9kdWxlc1xcY2hhcnRqcy1wbHVnaW4tem9vbVxcZGlzdFxcY2hhcnRqcy1wbHVnaW4tem9vbS5lc20uanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4qIGNoYXJ0anMtcGx1Z2luLXpvb20gdjIuMS4wXG4qIGh0dHBzOi8vd3d3LmNoYXJ0anMub3JnL2NoYXJ0anMtcGx1Z2luLXpvb20vMi4xLjAvXG4gKiAoYykgMjAxNi0yMDI0IGNoYXJ0anMtcGx1Z2luLXpvb20gQ29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqL1xuaW1wb3J0IEhhbW1lciBmcm9tICdoYW1tZXJqcyc7XG5pbXBvcnQgeyBlYWNoLCB2YWx1ZU9yRGVmYXVsdCwgYWxtb3N0RXF1YWxzLCBjYWxsYmFjaywgc2lnbiwgZ2V0UmVsYXRpdmVQb3NpdGlvbiwgX2lzUG9pbnRJbkFyZWEgfSBmcm9tICdjaGFydC5qcy9oZWxwZXJzJztcblxuY29uc3QgZ2V0TW9kaWZpZXJLZXkgPSBvcHRzID0+IG9wdHMgJiYgb3B0cy5lbmFibGVkICYmIG9wdHMubW9kaWZpZXJLZXk7XG5jb25zdCBrZXlQcmVzc2VkID0gKGtleSwgZXZlbnQpID0+IGtleSAmJiBldmVudFtrZXkgKyAnS2V5J107XG5jb25zdCBrZXlOb3RQcmVzc2VkID0gKGtleSwgZXZlbnQpID0+IGtleSAmJiAhZXZlbnRba2V5ICsgJ0tleSddO1xuZnVuY3Rpb24gZGlyZWN0aW9uRW5hYmxlZChtb2RlLCBkaXIsIGNoYXJ0KSB7XG4gIGlmIChtb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgbW9kZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gbW9kZS5pbmRleE9mKGRpcikgIT09IC0xO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBtb2RlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1vZGUoe2NoYXJ0fSkuaW5kZXhPZihkaXIpICE9PSAtMTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBkaXJlY3Rpb25zRW5hYmxlZChtb2RlLCBjaGFydCkge1xuICBpZiAodHlwZW9mIG1vZGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBtb2RlID0gbW9kZSh7Y2hhcnR9KTtcbiAgfVxuICBpZiAodHlwZW9mIG1vZGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHt4OiBtb2RlLmluZGV4T2YoJ3gnKSAhPT0gLTEsIHk6IG1vZGUuaW5kZXhPZigneScpICE9PSAtMX07XG4gIH1cbiAgcmV0dXJuIHt4OiBmYWxzZSwgeTogZmFsc2V9O1xufVxuZnVuY3Rpb24gZGVib3VuY2UoZm4sIGRlbGF5KSB7XG4gIGxldCB0aW1lb3V0O1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZuLCBkZWxheSk7XG4gICAgcmV0dXJuIGRlbGF5O1xuICB9O1xufVxuZnVuY3Rpb24gZ2V0U2NhbGVVbmRlclBvaW50KHt4LCB5fSwgY2hhcnQpIHtcbiAgY29uc3Qgc2NhbGVzID0gY2hhcnQuc2NhbGVzO1xuICBjb25zdCBzY2FsZUlkcyA9IE9iamVjdC5rZXlzKHNjYWxlcyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2NhbGVJZHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzY2FsZSA9IHNjYWxlc1tzY2FsZUlkc1tpXV07XG4gICAgaWYgKHkgPj0gc2NhbGUudG9wICYmIHkgPD0gc2NhbGUuYm90dG9tICYmIHggPj0gc2NhbGUubGVmdCAmJiB4IDw9IHNjYWxlLnJpZ2h0KSB7XG4gICAgICByZXR1cm4gc2NhbGU7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0RW5hYmxlZFNjYWxlc0J5UG9pbnQob3B0aW9ucywgcG9pbnQsIGNoYXJ0KSB7XG4gIGNvbnN0IHttb2RlID0gJ3h5Jywgc2NhbGVNb2RlLCBvdmVyU2NhbGVNb2RlfSA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IHNjYWxlID0gZ2V0U2NhbGVVbmRlclBvaW50KHBvaW50LCBjaGFydCk7XG4gIGNvbnN0IGVuYWJsZWQgPSBkaXJlY3Rpb25zRW5hYmxlZChtb2RlLCBjaGFydCk7XG4gIGNvbnN0IHNjYWxlRW5hYmxlZCA9IGRpcmVjdGlvbnNFbmFibGVkKHNjYWxlTW9kZSwgY2hhcnQpO1xuICBpZiAob3ZlclNjYWxlTW9kZSkge1xuICAgIGNvbnN0IG92ZXJTY2FsZUVuYWJsZWQgPSBkaXJlY3Rpb25zRW5hYmxlZChvdmVyU2NhbGVNb2RlLCBjaGFydCk7XG4gICAgZm9yIChjb25zdCBheGlzIG9mIFsneCcsICd5J10pIHtcbiAgICAgIGlmIChvdmVyU2NhbGVFbmFibGVkW2F4aXNdKSB7XG4gICAgICAgIHNjYWxlRW5hYmxlZFtheGlzXSA9IGVuYWJsZWRbYXhpc107XG4gICAgICAgIGVuYWJsZWRbYXhpc10gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHNjYWxlICYmIHNjYWxlRW5hYmxlZFtzY2FsZS5heGlzXSkge1xuICAgIHJldHVybiBbc2NhbGVdO1xuICB9XG4gIGNvbnN0IGVuYWJsZWRTY2FsZXMgPSBbXTtcbiAgZWFjaChjaGFydC5zY2FsZXMsIGZ1bmN0aW9uKHNjYWxlSXRlbSkge1xuICAgIGlmIChlbmFibGVkW3NjYWxlSXRlbS5heGlzXSkge1xuICAgICAgZW5hYmxlZFNjYWxlcy5wdXNoKHNjYWxlSXRlbSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGVuYWJsZWRTY2FsZXM7XG59XG5cbmNvbnN0IGNoYXJ0U3RhdGVzID0gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIGdldFN0YXRlKGNoYXJ0KSB7XG4gIGxldCBzdGF0ZSA9IGNoYXJ0U3RhdGVzLmdldChjaGFydCk7XG4gIGlmICghc3RhdGUpIHtcbiAgICBzdGF0ZSA9IHtcbiAgICAgIG9yaWdpbmFsU2NhbGVMaW1pdHM6IHt9LFxuICAgICAgdXBkYXRlZFNjYWxlTGltaXRzOiB7fSxcbiAgICAgIGhhbmRsZXJzOiB7fSxcbiAgICAgIHBhbkRlbHRhOiB7fSxcbiAgICAgIGRyYWdnaW5nOiBmYWxzZSxcbiAgICAgIHBhbm5pbmc6IGZhbHNlXG4gICAgfTtcbiAgICBjaGFydFN0YXRlcy5zZXQoY2hhcnQsIHN0YXRlKTtcbiAgfVxuICByZXR1cm4gc3RhdGU7XG59XG5mdW5jdGlvbiByZW1vdmVTdGF0ZShjaGFydCkge1xuICBjaGFydFN0YXRlcy5kZWxldGUoY2hhcnQpO1xufVxuXG5mdW5jdGlvbiB6b29tRGVsdGEodmFsLCBtaW4sIHJhbmdlLCBuZXdSYW5nZSkge1xuICBjb25zdCBtaW5QZXJjZW50ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgKHZhbCAtIG1pbikgLyByYW5nZSB8fCAwKSk7XG4gIGNvbnN0IG1heFBlcmNlbnQgPSAxIC0gbWluUGVyY2VudDtcbiAgcmV0dXJuIHtcbiAgICBtaW46IG5ld1JhbmdlICogbWluUGVyY2VudCxcbiAgICBtYXg6IG5ld1JhbmdlICogbWF4UGVyY2VudFxuICB9O1xufVxuZnVuY3Rpb24gZ2V0VmFsdWVBdFBvaW50KHNjYWxlLCBwb2ludCkge1xuICBjb25zdCBwaXhlbCA9IHNjYWxlLmlzSG9yaXpvbnRhbCgpID8gcG9pbnQueCA6IHBvaW50Lnk7XG4gIHJldHVybiBzY2FsZS5nZXRWYWx1ZUZvclBpeGVsKHBpeGVsKTtcbn1cbmZ1bmN0aW9uIGxpbmVhclpvb21EZWx0YShzY2FsZSwgem9vbSwgY2VudGVyKSB7XG4gIGNvbnN0IHJhbmdlID0gc2NhbGUubWF4IC0gc2NhbGUubWluO1xuICBjb25zdCBuZXdSYW5nZSA9IHJhbmdlICogKHpvb20gLSAxKTtcbiAgY29uc3QgY2VudGVyVmFsdWUgPSBnZXRWYWx1ZUF0UG9pbnQoc2NhbGUsIGNlbnRlcik7XG4gIHJldHVybiB6b29tRGVsdGEoY2VudGVyVmFsdWUsIHNjYWxlLm1pbiwgcmFuZ2UsIG5ld1JhbmdlKTtcbn1cbmZ1bmN0aW9uIGxvZ2FyaXRobWljWm9vbVJhbmdlKHNjYWxlLCB6b29tLCBjZW50ZXIpIHtcbiAgY29uc3QgY2VudGVyVmFsdWUgPSBnZXRWYWx1ZUF0UG9pbnQoc2NhbGUsIGNlbnRlcik7XG4gIGlmIChjZW50ZXJWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHttaW46IHNjYWxlLm1pbiwgbWF4OiBzY2FsZS5tYXh9O1xuICB9XG4gIGNvbnN0IGxvZ01pbiA9IE1hdGgubG9nMTAoc2NhbGUubWluKTtcbiAgY29uc3QgbG9nTWF4ID0gTWF0aC5sb2cxMChzY2FsZS5tYXgpO1xuICBjb25zdCBsb2dDZW50ZXIgPSBNYXRoLmxvZzEwKGNlbnRlclZhbHVlKTtcbiAgY29uc3QgbG9nUmFuZ2UgPSBsb2dNYXggLSBsb2dNaW47XG4gIGNvbnN0IG5ld0xvZ1JhbmdlID0gbG9nUmFuZ2UgKiAoem9vbSAtIDEpO1xuICBjb25zdCBkZWx0YSA9IHpvb21EZWx0YShsb2dDZW50ZXIsIGxvZ01pbiwgbG9nUmFuZ2UsIG5ld0xvZ1JhbmdlKTtcbiAgcmV0dXJuIHtcbiAgICBtaW46IE1hdGgucG93KDEwLCBsb2dNaW4gKyBkZWx0YS5taW4pLFxuICAgIG1heDogTWF0aC5wb3coMTAsIGxvZ01heCAtIGRlbHRhLm1heCksXG4gIH07XG59XG5mdW5jdGlvbiBnZXRTY2FsZUxpbWl0cyhzY2FsZSwgbGltaXRzKSB7XG4gIHJldHVybiBsaW1pdHMgJiYgKGxpbWl0c1tzY2FsZS5pZF0gfHwgbGltaXRzW3NjYWxlLmF4aXNdKSB8fCB7fTtcbn1cbmZ1bmN0aW9uIGdldExpbWl0KHN0YXRlLCBzY2FsZSwgc2NhbGVMaW1pdHMsIHByb3AsIGZhbGxiYWNrKSB7XG4gIGxldCBsaW1pdCA9IHNjYWxlTGltaXRzW3Byb3BdO1xuICBpZiAobGltaXQgPT09ICdvcmlnaW5hbCcpIHtcbiAgICBjb25zdCBvcmlnaW5hbCA9IHN0YXRlLm9yaWdpbmFsU2NhbGVMaW1pdHNbc2NhbGUuaWRdW3Byb3BdO1xuICAgIGxpbWl0ID0gdmFsdWVPckRlZmF1bHQob3JpZ2luYWwub3B0aW9ucywgb3JpZ2luYWwuc2NhbGUpO1xuICB9XG4gIHJldHVybiB2YWx1ZU9yRGVmYXVsdChsaW1pdCwgZmFsbGJhY2spO1xufVxuZnVuY3Rpb24gbGluZWFyUmFuZ2Uoc2NhbGUsIHBpeGVsMCwgcGl4ZWwxKSB7XG4gIGNvbnN0IHYwID0gc2NhbGUuZ2V0VmFsdWVGb3JQaXhlbChwaXhlbDApO1xuICBjb25zdCB2MSA9IHNjYWxlLmdldFZhbHVlRm9yUGl4ZWwocGl4ZWwxKTtcbiAgcmV0dXJuIHtcbiAgICBtaW46IE1hdGgubWluKHYwLCB2MSksXG4gICAgbWF4OiBNYXRoLm1heCh2MCwgdjEpXG4gIH07XG59XG5mdW5jdGlvbiBmaXhSYW5nZShyYW5nZSwge21pbiwgbWF4LCBtaW5MaW1pdCwgbWF4TGltaXR9LCBvcmlnaW5hbExpbWl0cykge1xuICBjb25zdCBvZmZzZXQgPSAocmFuZ2UgLSBtYXggKyBtaW4pIC8gMjtcbiAgbWluIC09IG9mZnNldDtcbiAgbWF4ICs9IG9mZnNldDtcbiAgY29uc3Qgb3JpZ01pbiA9IG9yaWdpbmFsTGltaXRzLm1pbi5vcHRpb25zID8/IG9yaWdpbmFsTGltaXRzLm1pbi5zY2FsZTtcbiAgY29uc3Qgb3JpZ01heCA9IG9yaWdpbmFsTGltaXRzLm1heC5vcHRpb25zID8/IG9yaWdpbmFsTGltaXRzLm1heC5zY2FsZTtcbiAgY29uc3QgZXBzaWxvbiA9IHJhbmdlIC8gMWU2O1xuICBpZiAoYWxtb3N0RXF1YWxzKG1pbiwgb3JpZ01pbiwgZXBzaWxvbikpIHtcbiAgICBtaW4gPSBvcmlnTWluO1xuICB9XG4gIGlmIChhbG1vc3RFcXVhbHMobWF4LCBvcmlnTWF4LCBlcHNpbG9uKSkge1xuICAgIG1heCA9IG9yaWdNYXg7XG4gIH1cbiAgaWYgKG1pbiA8IG1pbkxpbWl0KSB7XG4gICAgbWluID0gbWluTGltaXQ7XG4gICAgbWF4ID0gTWF0aC5taW4obWluTGltaXQgKyByYW5nZSwgbWF4TGltaXQpO1xuICB9IGVsc2UgaWYgKG1heCA+IG1heExpbWl0KSB7XG4gICAgbWF4ID0gbWF4TGltaXQ7XG4gICAgbWluID0gTWF0aC5tYXgobWF4TGltaXQgLSByYW5nZSwgbWluTGltaXQpO1xuICB9XG4gIHJldHVybiB7bWluLCBtYXh9O1xufVxuZnVuY3Rpb24gdXBkYXRlUmFuZ2Uoc2NhbGUsIHttaW4sIG1heH0sIGxpbWl0cywgem9vbSA9IGZhbHNlKSB7XG4gIGNvbnN0IHN0YXRlID0gZ2V0U3RhdGUoc2NhbGUuY2hhcnQpO1xuICBjb25zdCB7b3B0aW9uczogc2NhbGVPcHRzfSA9IHNjYWxlO1xuICBjb25zdCBzY2FsZUxpbWl0cyA9IGdldFNjYWxlTGltaXRzKHNjYWxlLCBsaW1pdHMpO1xuICBjb25zdCB7bWluUmFuZ2UgPSAwfSA9IHNjYWxlTGltaXRzO1xuICBjb25zdCBtaW5MaW1pdCA9IGdldExpbWl0KHN0YXRlLCBzY2FsZSwgc2NhbGVMaW1pdHMsICdtaW4nLCAtSW5maW5pdHkpO1xuICBjb25zdCBtYXhMaW1pdCA9IGdldExpbWl0KHN0YXRlLCBzY2FsZSwgc2NhbGVMaW1pdHMsICdtYXgnLCBJbmZpbml0eSk7XG4gIGlmICh6b29tID09PSAncGFuJyAmJiAobWluIDwgbWluTGltaXQgfHwgbWF4ID4gbWF4TGltaXQpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3Qgc2NhbGVSYW5nZSA9IHNjYWxlLm1heCAtIHNjYWxlLm1pbjtcbiAgY29uc3QgcmFuZ2UgPSB6b29tID8gTWF0aC5tYXgobWF4IC0gbWluLCBtaW5SYW5nZSkgOiBzY2FsZVJhbmdlO1xuICBpZiAoem9vbSAmJiByYW5nZSA9PT0gbWluUmFuZ2UgJiYgc2NhbGVSYW5nZSA8PSBtaW5SYW5nZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IG5ld1JhbmdlID0gZml4UmFuZ2UocmFuZ2UsIHttaW4sIG1heCwgbWluTGltaXQsIG1heExpbWl0fSwgc3RhdGUub3JpZ2luYWxTY2FsZUxpbWl0c1tzY2FsZS5pZF0pO1xuICBzY2FsZU9wdHMubWluID0gbmV3UmFuZ2UubWluO1xuICBzY2FsZU9wdHMubWF4ID0gbmV3UmFuZ2UubWF4O1xuICBzdGF0ZS51cGRhdGVkU2NhbGVMaW1pdHNbc2NhbGUuaWRdID0gbmV3UmFuZ2U7XG4gIHJldHVybiBzY2FsZS5wYXJzZShuZXdSYW5nZS5taW4pICE9PSBzY2FsZS5taW4gfHwgc2NhbGUucGFyc2UobmV3UmFuZ2UubWF4KSAhPT0gc2NhbGUubWF4O1xufVxuZnVuY3Rpb24gem9vbU51bWVyaWNhbFNjYWxlKHNjYWxlLCB6b29tLCBjZW50ZXIsIGxpbWl0cykge1xuICBjb25zdCBkZWx0YSA9IGxpbmVhclpvb21EZWx0YShzY2FsZSwgem9vbSwgY2VudGVyKTtcbiAgY29uc3QgbmV3UmFuZ2UgPSB7bWluOiBzY2FsZS5taW4gKyBkZWx0YS5taW4sIG1heDogc2NhbGUubWF4IC0gZGVsdGEubWF4fTtcbiAgcmV0dXJuIHVwZGF0ZVJhbmdlKHNjYWxlLCBuZXdSYW5nZSwgbGltaXRzLCB0cnVlKTtcbn1cbmZ1bmN0aW9uIHpvb21Mb2dhcml0aG1pY1NjYWxlKHNjYWxlLCB6b29tLCBjZW50ZXIsIGxpbWl0cykge1xuICBjb25zdCBuZXdSYW5nZSA9IGxvZ2FyaXRobWljWm9vbVJhbmdlKHNjYWxlLCB6b29tLCBjZW50ZXIpO1xuICByZXR1cm4gdXBkYXRlUmFuZ2Uoc2NhbGUsIG5ld1JhbmdlLCBsaW1pdHMsIHRydWUpO1xufVxuZnVuY3Rpb24gem9vbVJlY3ROdW1lcmljYWxTY2FsZShzY2FsZSwgZnJvbSwgdG8sIGxpbWl0cykge1xuICB1cGRhdGVSYW5nZShzY2FsZSwgbGluZWFyUmFuZ2Uoc2NhbGUsIGZyb20sIHRvKSwgbGltaXRzLCB0cnVlKTtcbn1cbmNvbnN0IGludGVnZXJDaGFuZ2UgPSAodikgPT4gdiA9PT0gMCB8fCBpc05hTih2KSA/IDAgOiB2IDwgMCA/IE1hdGgubWluKE1hdGgucm91bmQodiksIC0xKSA6IE1hdGgubWF4KE1hdGgucm91bmQodiksIDEpO1xuZnVuY3Rpb24gZXhpc3RDYXRlZ29yeUZyb21NYXhab29tKHNjYWxlKSB7XG4gIGNvbnN0IGxhYmVscyA9IHNjYWxlLmdldExhYmVscygpO1xuICBjb25zdCBtYXhJbmRleCA9IGxhYmVscy5sZW5ndGggLSAxO1xuICBpZiAoc2NhbGUubWluID4gMCkge1xuICAgIHNjYWxlLm1pbiAtPSAxO1xuICB9XG4gIGlmIChzY2FsZS5tYXggPCBtYXhJbmRleCkge1xuICAgIHNjYWxlLm1heCArPSAxO1xuICB9XG59XG5mdW5jdGlvbiB6b29tQ2F0ZWdvcnlTY2FsZShzY2FsZSwgem9vbSwgY2VudGVyLCBsaW1pdHMpIHtcbiAgY29uc3QgZGVsdGEgPSBsaW5lYXJab29tRGVsdGEoc2NhbGUsIHpvb20sIGNlbnRlcik7XG4gIGlmIChzY2FsZS5taW4gPT09IHNjYWxlLm1heCAmJiB6b29tIDwgMSkge1xuICAgIGV4aXN0Q2F0ZWdvcnlGcm9tTWF4Wm9vbShzY2FsZSk7XG4gIH1cbiAgY29uc3QgbmV3UmFuZ2UgPSB7bWluOiBzY2FsZS5taW4gKyBpbnRlZ2VyQ2hhbmdlKGRlbHRhLm1pbiksIG1heDogc2NhbGUubWF4IC0gaW50ZWdlckNoYW5nZShkZWx0YS5tYXgpfTtcbiAgcmV0dXJuIHVwZGF0ZVJhbmdlKHNjYWxlLCBuZXdSYW5nZSwgbGltaXRzLCB0cnVlKTtcbn1cbmZ1bmN0aW9uIHNjYWxlTGVuZ3RoKHNjYWxlKSB7XG4gIHJldHVybiBzY2FsZS5pc0hvcml6b250YWwoKSA/IHNjYWxlLndpZHRoIDogc2NhbGUuaGVpZ2h0O1xufVxuZnVuY3Rpb24gcGFuQ2F0ZWdvcnlTY2FsZShzY2FsZSwgZGVsdGEsIGxpbWl0cykge1xuICBjb25zdCBsYWJlbHMgPSBzY2FsZS5nZXRMYWJlbHMoKTtcbiAgY29uc3QgbGFzdExhYmVsSW5kZXggPSBsYWJlbHMubGVuZ3RoIC0gMTtcbiAgbGV0IHttaW4sIG1heH0gPSBzY2FsZTtcbiAgY29uc3QgcmFuZ2UgPSBNYXRoLm1heChtYXggLSBtaW4sIDEpO1xuICBjb25zdCBzdGVwRGVsdGEgPSBNYXRoLnJvdW5kKHNjYWxlTGVuZ3RoKHNjYWxlKSAvIE1hdGgubWF4KHJhbmdlLCAxMCkpO1xuICBjb25zdCBzdGVwU2l6ZSA9IE1hdGgucm91bmQoTWF0aC5hYnMoZGVsdGEgLyBzdGVwRGVsdGEpKTtcbiAgbGV0IGFwcGxpZWQ7XG4gIGlmIChkZWx0YSA8IC1zdGVwRGVsdGEpIHtcbiAgICBtYXggPSBNYXRoLm1pbihtYXggKyBzdGVwU2l6ZSwgbGFzdExhYmVsSW5kZXgpO1xuICAgIG1pbiA9IHJhbmdlID09PSAxID8gbWF4IDogbWF4IC0gcmFuZ2U7XG4gICAgYXBwbGllZCA9IG1heCA9PT0gbGFzdExhYmVsSW5kZXg7XG4gIH0gZWxzZSBpZiAoZGVsdGEgPiBzdGVwRGVsdGEpIHtcbiAgICBtaW4gPSBNYXRoLm1heCgwLCBtaW4gLSBzdGVwU2l6ZSk7XG4gICAgbWF4ID0gcmFuZ2UgPT09IDEgPyBtaW4gOiBtaW4gKyByYW5nZTtcbiAgICBhcHBsaWVkID0gbWluID09PSAwO1xuICB9XG4gIHJldHVybiB1cGRhdGVSYW5nZShzY2FsZSwge21pbiwgbWF4fSwgbGltaXRzKSB8fCBhcHBsaWVkO1xufVxuY29uc3QgT0ZGU0VUUyA9IHtcbiAgc2Vjb25kOiA1MDAsXG4gIG1pbnV0ZTogMzAgKiAxMDAwLFxuICBob3VyOiAzMCAqIDYwICogMTAwMCxcbiAgZGF5OiAxMiAqIDYwICogNjAgKiAxMDAwLFxuICB3ZWVrOiAzLjUgKiAyNCAqIDYwICogNjAgKiAxMDAwLFxuICBtb250aDogMTUgKiAyNCAqIDYwICogNjAgKiAxMDAwLFxuICBxdWFydGVyOiA2MCAqIDI0ICogNjAgKiA2MCAqIDEwMDAsXG4gIHllYXI6IDE4MiAqIDI0ICogNjAgKiA2MCAqIDEwMDBcbn07XG5mdW5jdGlvbiBwYW5OdW1lcmljYWxTY2FsZShzY2FsZSwgZGVsdGEsIGxpbWl0cywgcGFuID0gZmFsc2UpIHtcbiAgY29uc3Qge21pbjogcHJldlN0YXJ0LCBtYXg6IHByZXZFbmQsIG9wdGlvbnN9ID0gc2NhbGU7XG4gIGNvbnN0IHJvdW5kID0gb3B0aW9ucy50aW1lICYmIG9wdGlvbnMudGltZS5yb3VuZDtcbiAgY29uc3Qgb2Zmc2V0ID0gT0ZGU0VUU1tyb3VuZF0gfHwgMDtcbiAgY29uc3QgbmV3TWluID0gc2NhbGUuZ2V0VmFsdWVGb3JQaXhlbChzY2FsZS5nZXRQaXhlbEZvclZhbHVlKHByZXZTdGFydCArIG9mZnNldCkgLSBkZWx0YSk7XG4gIGNvbnN0IG5ld01heCA9IHNjYWxlLmdldFZhbHVlRm9yUGl4ZWwoc2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShwcmV2RW5kICsgb2Zmc2V0KSAtIGRlbHRhKTtcbiAgaWYgKGlzTmFOKG5ld01pbikgfHwgaXNOYU4obmV3TWF4KSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiB1cGRhdGVSYW5nZShzY2FsZSwge21pbjogbmV3TWluLCBtYXg6IG5ld01heH0sIGxpbWl0cywgcGFuID8gJ3BhbicgOiBmYWxzZSk7XG59XG5mdW5jdGlvbiBwYW5Ob25MaW5lYXJTY2FsZShzY2FsZSwgZGVsdGEsIGxpbWl0cykge1xuICByZXR1cm4gcGFuTnVtZXJpY2FsU2NhbGUoc2NhbGUsIGRlbHRhLCBsaW1pdHMsIHRydWUpO1xufVxuY29uc3Qgem9vbUZ1bmN0aW9ucyA9IHtcbiAgY2F0ZWdvcnk6IHpvb21DYXRlZ29yeVNjYWxlLFxuICBkZWZhdWx0OiB6b29tTnVtZXJpY2FsU2NhbGUsXG4gIGxvZ2FyaXRobWljOiB6b29tTG9nYXJpdGhtaWNTY2FsZSxcbn07XG5jb25zdCB6b29tUmVjdEZ1bmN0aW9ucyA9IHtcbiAgZGVmYXVsdDogem9vbVJlY3ROdW1lcmljYWxTY2FsZSxcbn07XG5jb25zdCBwYW5GdW5jdGlvbnMgPSB7XG4gIGNhdGVnb3J5OiBwYW5DYXRlZ29yeVNjYWxlLFxuICBkZWZhdWx0OiBwYW5OdW1lcmljYWxTY2FsZSxcbiAgbG9nYXJpdGhtaWM6IHBhbk5vbkxpbmVhclNjYWxlLFxuICB0aW1lc2VyaWVzOiBwYW5Ob25MaW5lYXJTY2FsZSxcbn07XG5cbmZ1bmN0aW9uIHNob3VsZFVwZGF0ZVNjYWxlTGltaXRzKHNjYWxlLCBvcmlnaW5hbFNjYWxlTGltaXRzLCB1cGRhdGVkU2NhbGVMaW1pdHMpIHtcbiAgY29uc3Qge2lkLCBvcHRpb25zOiB7bWluLCBtYXh9fSA9IHNjYWxlO1xuICBpZiAoIW9yaWdpbmFsU2NhbGVMaW1pdHNbaWRdIHx8ICF1cGRhdGVkU2NhbGVMaW1pdHNbaWRdKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgcHJldmlvdXMgPSB1cGRhdGVkU2NhbGVMaW1pdHNbaWRdO1xuICByZXR1cm4gcHJldmlvdXMubWluICE9PSBtaW4gfHwgcHJldmlvdXMubWF4ICE9PSBtYXg7XG59XG5mdW5jdGlvbiByZW1vdmVNaXNzaW5nU2NhbGVzKGxpbWl0cywgc2NhbGVzKSB7XG4gIGVhY2gobGltaXRzLCAob3B0LCBrZXkpID0+IHtcbiAgICBpZiAoIXNjYWxlc1trZXldKSB7XG4gICAgICBkZWxldGUgbGltaXRzW2tleV07XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHN0b3JlT3JpZ2luYWxTY2FsZUxpbWl0cyhjaGFydCwgc3RhdGUpIHtcbiAgY29uc3Qge3NjYWxlc30gPSBjaGFydDtcbiAgY29uc3Qge29yaWdpbmFsU2NhbGVMaW1pdHMsIHVwZGF0ZWRTY2FsZUxpbWl0c30gPSBzdGF0ZTtcbiAgZWFjaChzY2FsZXMsIGZ1bmN0aW9uKHNjYWxlKSB7XG4gICAgaWYgKHNob3VsZFVwZGF0ZVNjYWxlTGltaXRzKHNjYWxlLCBvcmlnaW5hbFNjYWxlTGltaXRzLCB1cGRhdGVkU2NhbGVMaW1pdHMpKSB7XG4gICAgICBvcmlnaW5hbFNjYWxlTGltaXRzW3NjYWxlLmlkXSA9IHtcbiAgICAgICAgbWluOiB7c2NhbGU6IHNjYWxlLm1pbiwgb3B0aW9uczogc2NhbGUub3B0aW9ucy5taW59LFxuICAgICAgICBtYXg6IHtzY2FsZTogc2NhbGUubWF4LCBvcHRpb25zOiBzY2FsZS5vcHRpb25zLm1heH0sXG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG4gIHJlbW92ZU1pc3NpbmdTY2FsZXMob3JpZ2luYWxTY2FsZUxpbWl0cywgc2NhbGVzKTtcbiAgcmVtb3ZlTWlzc2luZ1NjYWxlcyh1cGRhdGVkU2NhbGVMaW1pdHMsIHNjYWxlcyk7XG4gIHJldHVybiBvcmlnaW5hbFNjYWxlTGltaXRzO1xufVxuZnVuY3Rpb24gZG9ab29tKHNjYWxlLCBhbW91bnQsIGNlbnRlciwgbGltaXRzKSB7XG4gIGNvbnN0IGZuID0gem9vbUZ1bmN0aW9uc1tzY2FsZS50eXBlXSB8fCB6b29tRnVuY3Rpb25zLmRlZmF1bHQ7XG4gIGNhbGxiYWNrKGZuLCBbc2NhbGUsIGFtb3VudCwgY2VudGVyLCBsaW1pdHNdKTtcbn1cbmZ1bmN0aW9uIGRvWm9vbVJlY3Qoc2NhbGUsIGZyb20sIHRvLCBsaW1pdHMpIHtcbiAgY29uc3QgZm4gPSB6b29tUmVjdEZ1bmN0aW9uc1tzY2FsZS50eXBlXSB8fCB6b29tUmVjdEZ1bmN0aW9ucy5kZWZhdWx0O1xuICBjYWxsYmFjayhmbiwgW3NjYWxlLCBmcm9tLCB0bywgbGltaXRzXSk7XG59XG5mdW5jdGlvbiBnZXRDZW50ZXIoY2hhcnQpIHtcbiAgY29uc3QgY2EgPSBjaGFydC5jaGFydEFyZWE7XG4gIHJldHVybiB7XG4gICAgeDogKGNhLmxlZnQgKyBjYS5yaWdodCkgLyAyLFxuICAgIHk6IChjYS50b3AgKyBjYS5ib3R0b20pIC8gMixcbiAgfTtcbn1cbmZ1bmN0aW9uIHpvb20oY2hhcnQsIGFtb3VudCwgdHJhbnNpdGlvbiA9ICdub25lJykge1xuICBjb25zdCB7eCA9IDEsIHkgPSAxLCBmb2NhbFBvaW50ID0gZ2V0Q2VudGVyKGNoYXJ0KX0gPSB0eXBlb2YgYW1vdW50ID09PSAnbnVtYmVyJyA/IHt4OiBhbW91bnQsIHk6IGFtb3VudH0gOiBhbW91bnQ7XG4gIGNvbnN0IHN0YXRlID0gZ2V0U3RhdGUoY2hhcnQpO1xuICBjb25zdCB7b3B0aW9uczoge2xpbWl0cywgem9vbTogem9vbU9wdGlvbnN9fSA9IHN0YXRlO1xuICBzdG9yZU9yaWdpbmFsU2NhbGVMaW1pdHMoY2hhcnQsIHN0YXRlKTtcbiAgY29uc3QgeEVuYWJsZWQgPSB4ICE9PSAxO1xuICBjb25zdCB5RW5hYmxlZCA9IHkgIT09IDE7XG4gIGNvbnN0IGVuYWJsZWRTY2FsZXMgPSBnZXRFbmFibGVkU2NhbGVzQnlQb2ludCh6b29tT3B0aW9ucywgZm9jYWxQb2ludCwgY2hhcnQpO1xuICBlYWNoKGVuYWJsZWRTY2FsZXMgfHwgY2hhcnQuc2NhbGVzLCBmdW5jdGlvbihzY2FsZSkge1xuICAgIGlmIChzY2FsZS5pc0hvcml6b250YWwoKSAmJiB4RW5hYmxlZCkge1xuICAgICAgZG9ab29tKHNjYWxlLCB4LCBmb2NhbFBvaW50LCBsaW1pdHMpO1xuICAgIH0gZWxzZSBpZiAoIXNjYWxlLmlzSG9yaXpvbnRhbCgpICYmIHlFbmFibGVkKSB7XG4gICAgICBkb1pvb20oc2NhbGUsIHksIGZvY2FsUG9pbnQsIGxpbWl0cyk7XG4gICAgfVxuICB9KTtcbiAgY2hhcnQudXBkYXRlKHRyYW5zaXRpb24pO1xuICBjYWxsYmFjayh6b29tT3B0aW9ucy5vblpvb20sIFt7Y2hhcnR9XSk7XG59XG5mdW5jdGlvbiB6b29tUmVjdChjaGFydCwgcDAsIHAxLCB0cmFuc2l0aW9uID0gJ25vbmUnKSB7XG4gIGNvbnN0IHN0YXRlID0gZ2V0U3RhdGUoY2hhcnQpO1xuICBjb25zdCB7b3B0aW9uczoge2xpbWl0cywgem9vbTogem9vbU9wdGlvbnN9fSA9IHN0YXRlO1xuICBjb25zdCB7bW9kZSA9ICd4eSd9ID0gem9vbU9wdGlvbnM7XG4gIHN0b3JlT3JpZ2luYWxTY2FsZUxpbWl0cyhjaGFydCwgc3RhdGUpO1xuICBjb25zdCB4RW5hYmxlZCA9IGRpcmVjdGlvbkVuYWJsZWQobW9kZSwgJ3gnLCBjaGFydCk7XG4gIGNvbnN0IHlFbmFibGVkID0gZGlyZWN0aW9uRW5hYmxlZChtb2RlLCAneScsIGNoYXJ0KTtcbiAgZWFjaChjaGFydC5zY2FsZXMsIGZ1bmN0aW9uKHNjYWxlKSB7XG4gICAgaWYgKHNjYWxlLmlzSG9yaXpvbnRhbCgpICYmIHhFbmFibGVkKSB7XG4gICAgICBkb1pvb21SZWN0KHNjYWxlLCBwMC54LCBwMS54LCBsaW1pdHMpO1xuICAgIH0gZWxzZSBpZiAoIXNjYWxlLmlzSG9yaXpvbnRhbCgpICYmIHlFbmFibGVkKSB7XG4gICAgICBkb1pvb21SZWN0KHNjYWxlLCBwMC55LCBwMS55LCBsaW1pdHMpO1xuICAgIH1cbiAgfSk7XG4gIGNoYXJ0LnVwZGF0ZSh0cmFuc2l0aW9uKTtcbiAgY2FsbGJhY2soem9vbU9wdGlvbnMub25ab29tLCBbe2NoYXJ0fV0pO1xufVxuZnVuY3Rpb24gem9vbVNjYWxlKGNoYXJ0LCBzY2FsZUlkLCByYW5nZSwgdHJhbnNpdGlvbiA9ICdub25lJykge1xuICBjb25zdCBzdGF0ZSA9IGdldFN0YXRlKGNoYXJ0KTtcbiAgc3RvcmVPcmlnaW5hbFNjYWxlTGltaXRzKGNoYXJ0LCBzdGF0ZSk7XG4gIGNvbnN0IHNjYWxlID0gY2hhcnQuc2NhbGVzW3NjYWxlSWRdO1xuICB1cGRhdGVSYW5nZShzY2FsZSwgcmFuZ2UsIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gIGNoYXJ0LnVwZGF0ZSh0cmFuc2l0aW9uKTtcbiAgY2FsbGJhY2soc3RhdGUub3B0aW9ucy56b29tPy5vblpvb20sIFt7Y2hhcnR9XSk7XG59XG5mdW5jdGlvbiByZXNldFpvb20oY2hhcnQsIHRyYW5zaXRpb24gPSAnZGVmYXVsdCcpIHtcbiAgY29uc3Qgc3RhdGUgPSBnZXRTdGF0ZShjaGFydCk7XG4gIGNvbnN0IG9yaWdpbmFsU2NhbGVMaW1pdHMgPSBzdG9yZU9yaWdpbmFsU2NhbGVMaW1pdHMoY2hhcnQsIHN0YXRlKTtcbiAgZWFjaChjaGFydC5zY2FsZXMsIGZ1bmN0aW9uKHNjYWxlKSB7XG4gICAgY29uc3Qgc2NhbGVPcHRpb25zID0gc2NhbGUub3B0aW9ucztcbiAgICBpZiAob3JpZ2luYWxTY2FsZUxpbWl0c1tzY2FsZS5pZF0pIHtcbiAgICAgIHNjYWxlT3B0aW9ucy5taW4gPSBvcmlnaW5hbFNjYWxlTGltaXRzW3NjYWxlLmlkXS5taW4ub3B0aW9ucztcbiAgICAgIHNjYWxlT3B0aW9ucy5tYXggPSBvcmlnaW5hbFNjYWxlTGltaXRzW3NjYWxlLmlkXS5tYXgub3B0aW9ucztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHNjYWxlT3B0aW9ucy5taW47XG4gICAgICBkZWxldGUgc2NhbGVPcHRpb25zLm1heDtcbiAgICB9XG4gICAgZGVsZXRlIHN0YXRlLnVwZGF0ZWRTY2FsZUxpbWl0c1tzY2FsZS5pZF07XG4gIH0pO1xuICBjaGFydC51cGRhdGUodHJhbnNpdGlvbik7XG4gIGNhbGxiYWNrKHN0YXRlLm9wdGlvbnMuem9vbS5vblpvb21Db21wbGV0ZSwgW3tjaGFydH1dKTtcbn1cbmZ1bmN0aW9uIGdldE9yaWdpbmFsUmFuZ2Uoc3RhdGUsIHNjYWxlSWQpIHtcbiAgY29uc3Qgb3JpZ2luYWwgPSBzdGF0ZS5vcmlnaW5hbFNjYWxlTGltaXRzW3NjYWxlSWRdO1xuICBpZiAoIW9yaWdpbmFsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHttaW4sIG1heH0gPSBvcmlnaW5hbDtcbiAgcmV0dXJuIHZhbHVlT3JEZWZhdWx0KG1heC5vcHRpb25zLCBtYXguc2NhbGUpIC0gdmFsdWVPckRlZmF1bHQobWluLm9wdGlvbnMsIG1pbi5zY2FsZSk7XG59XG5mdW5jdGlvbiBnZXRab29tTGV2ZWwoY2hhcnQpIHtcbiAgY29uc3Qgc3RhdGUgPSBnZXRTdGF0ZShjaGFydCk7XG4gIGxldCBtaW4gPSAxO1xuICBsZXQgbWF4ID0gMTtcbiAgZWFjaChjaGFydC5zY2FsZXMsIGZ1bmN0aW9uKHNjYWxlKSB7XG4gICAgY29uc3Qgb3JpZ1JhbmdlID0gZ2V0T3JpZ2luYWxSYW5nZShzdGF0ZSwgc2NhbGUuaWQpO1xuICAgIGlmIChvcmlnUmFuZ2UpIHtcbiAgICAgIGNvbnN0IGxldmVsID0gTWF0aC5yb3VuZChvcmlnUmFuZ2UgLyAoc2NhbGUubWF4IC0gc2NhbGUubWluKSAqIDEwMCkgLyAxMDA7XG4gICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIGxldmVsKTtcbiAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgbGV2ZWwpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBtaW4gPCAxID8gbWluIDogbWF4O1xufVxuZnVuY3Rpb24gcGFuU2NhbGUoc2NhbGUsIGRlbHRhLCBsaW1pdHMsIHN0YXRlKSB7XG4gIGNvbnN0IHtwYW5EZWx0YX0gPSBzdGF0ZTtcbiAgY29uc3Qgc3RvcmVkRGVsdGEgPSBwYW5EZWx0YVtzY2FsZS5pZF0gfHwgMDtcbiAgaWYgKHNpZ24oc3RvcmVkRGVsdGEpID09PSBzaWduKGRlbHRhKSkge1xuICAgIGRlbHRhICs9IHN0b3JlZERlbHRhO1xuICB9XG4gIGNvbnN0IGZuID0gcGFuRnVuY3Rpb25zW3NjYWxlLnR5cGVdIHx8IHBhbkZ1bmN0aW9ucy5kZWZhdWx0O1xuICBpZiAoY2FsbGJhY2soZm4sIFtzY2FsZSwgZGVsdGEsIGxpbWl0c10pKSB7XG4gICAgcGFuRGVsdGFbc2NhbGUuaWRdID0gMDtcbiAgfSBlbHNlIHtcbiAgICBwYW5EZWx0YVtzY2FsZS5pZF0gPSBkZWx0YTtcbiAgfVxufVxuZnVuY3Rpb24gcGFuKGNoYXJ0LCBkZWx0YSwgZW5hYmxlZFNjYWxlcywgdHJhbnNpdGlvbiA9ICdub25lJykge1xuICBjb25zdCB7eCA9IDAsIHkgPSAwfSA9IHR5cGVvZiBkZWx0YSA9PT0gJ251bWJlcicgPyB7eDogZGVsdGEsIHk6IGRlbHRhfSA6IGRlbHRhO1xuICBjb25zdCBzdGF0ZSA9IGdldFN0YXRlKGNoYXJ0KTtcbiAgY29uc3Qge29wdGlvbnM6IHtwYW46IHBhbk9wdGlvbnMsIGxpbWl0c319ID0gc3RhdGU7XG4gIGNvbnN0IHtvblBhbn0gPSBwYW5PcHRpb25zIHx8IHt9O1xuICBzdG9yZU9yaWdpbmFsU2NhbGVMaW1pdHMoY2hhcnQsIHN0YXRlKTtcbiAgY29uc3QgeEVuYWJsZWQgPSB4ICE9PSAwO1xuICBjb25zdCB5RW5hYmxlZCA9IHkgIT09IDA7XG4gIGVhY2goZW5hYmxlZFNjYWxlcyB8fCBjaGFydC5zY2FsZXMsIGZ1bmN0aW9uKHNjYWxlKSB7XG4gICAgaWYgKHNjYWxlLmlzSG9yaXpvbnRhbCgpICYmIHhFbmFibGVkKSB7XG4gICAgICBwYW5TY2FsZShzY2FsZSwgeCwgbGltaXRzLCBzdGF0ZSk7XG4gICAgfSBlbHNlIGlmICghc2NhbGUuaXNIb3Jpem9udGFsKCkgJiYgeUVuYWJsZWQpIHtcbiAgICAgIHBhblNjYWxlKHNjYWxlLCB5LCBsaW1pdHMsIHN0YXRlKTtcbiAgICB9XG4gIH0pO1xuICBjaGFydC51cGRhdGUodHJhbnNpdGlvbik7XG4gIGNhbGxiYWNrKG9uUGFuLCBbe2NoYXJ0fV0pO1xufVxuZnVuY3Rpb24gZ2V0SW5pdGlhbFNjYWxlQm91bmRzKGNoYXJ0KSB7XG4gIGNvbnN0IHN0YXRlID0gZ2V0U3RhdGUoY2hhcnQpO1xuICBzdG9yZU9yaWdpbmFsU2NhbGVMaW1pdHMoY2hhcnQsIHN0YXRlKTtcbiAgY29uc3Qgc2NhbGVCb3VuZHMgPSB7fTtcbiAgZm9yIChjb25zdCBzY2FsZUlkIG9mIE9iamVjdC5rZXlzKGNoYXJ0LnNjYWxlcykpIHtcbiAgICBjb25zdCB7bWluLCBtYXh9ID0gc3RhdGUub3JpZ2luYWxTY2FsZUxpbWl0c1tzY2FsZUlkXSB8fCB7bWluOiB7fSwgbWF4OiB7fX07XG4gICAgc2NhbGVCb3VuZHNbc2NhbGVJZF0gPSB7bWluOiBtaW4uc2NhbGUsIG1heDogbWF4LnNjYWxlfTtcbiAgfVxuICByZXR1cm4gc2NhbGVCb3VuZHM7XG59XG5mdW5jdGlvbiBnZXRab29tZWRTY2FsZUJvdW5kcyhjaGFydCkge1xuICBjb25zdCBzdGF0ZSA9IGdldFN0YXRlKGNoYXJ0KTtcbiAgY29uc3Qgc2NhbGVCb3VuZHMgPSB7fTtcbiAgZm9yIChjb25zdCBzY2FsZUlkIG9mIE9iamVjdC5rZXlzKGNoYXJ0LnNjYWxlcykpIHtcbiAgICBzY2FsZUJvdW5kc1tzY2FsZUlkXSA9IHN0YXRlLnVwZGF0ZWRTY2FsZUxpbWl0c1tzY2FsZUlkXTtcbiAgfVxuICByZXR1cm4gc2NhbGVCb3VuZHM7XG59XG5mdW5jdGlvbiBpc1pvb21lZE9yUGFubmVkKGNoYXJ0KSB7XG4gIGNvbnN0IHNjYWxlQm91bmRzID0gZ2V0SW5pdGlhbFNjYWxlQm91bmRzKGNoYXJ0KTtcbiAgZm9yIChjb25zdCBzY2FsZUlkIG9mIE9iamVjdC5rZXlzKGNoYXJ0LnNjYWxlcykpIHtcbiAgICBjb25zdCB7bWluOiBvcmlnaW5hbE1pbiwgbWF4OiBvcmlnaW5hbE1heH0gPSBzY2FsZUJvdW5kc1tzY2FsZUlkXTtcbiAgICBpZiAob3JpZ2luYWxNaW4gIT09IHVuZGVmaW5lZCAmJiBjaGFydC5zY2FsZXNbc2NhbGVJZF0ubWluICE9PSBvcmlnaW5hbE1pbikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChvcmlnaW5hbE1heCAhPT0gdW5kZWZpbmVkICYmIGNoYXJ0LnNjYWxlc1tzY2FsZUlkXS5tYXggIT09IG9yaWdpbmFsTWF4KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNab29taW5nT3JQYW5uaW5nKGNoYXJ0KSB7XG4gIGNvbnN0IHN0YXRlID0gZ2V0U3RhdGUoY2hhcnQpO1xuICByZXR1cm4gc3RhdGUucGFubmluZyB8fCBzdGF0ZS5kcmFnZ2luZztcbn1cblxuZnVuY3Rpb24gcmVtb3ZlSGFuZGxlcihjaGFydCwgdHlwZSkge1xuICBjb25zdCB7aGFuZGxlcnN9ID0gZ2V0U3RhdGUoY2hhcnQpO1xuICBjb25zdCBoYW5kbGVyID0gaGFuZGxlcnNbdHlwZV07XG4gIGlmIChoYW5kbGVyICYmIGhhbmRsZXIudGFyZ2V0KSB7XG4gICAgaGFuZGxlci50YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKTtcbiAgICBkZWxldGUgaGFuZGxlcnNbdHlwZV07XG4gIH1cbn1cbmZ1bmN0aW9uIGFkZEhhbmRsZXIoY2hhcnQsIHRhcmdldCwgdHlwZSwgaGFuZGxlcikge1xuICBjb25zdCB7aGFuZGxlcnMsIG9wdGlvbnN9ID0gZ2V0U3RhdGUoY2hhcnQpO1xuICBjb25zdCBvbGRIYW5kbGVyID0gaGFuZGxlcnNbdHlwZV07XG4gIGlmIChvbGRIYW5kbGVyICYmIG9sZEhhbmRsZXIudGFyZ2V0ID09PSB0YXJnZXQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcmVtb3ZlSGFuZGxlcihjaGFydCwgdHlwZSk7XG4gIGhhbmRsZXJzW3R5cGVdID0gKGV2ZW50KSA9PiBoYW5kbGVyKGNoYXJ0LCBldmVudCwgb3B0aW9ucyk7XG4gIGhhbmRsZXJzW3R5cGVdLnRhcmdldCA9IHRhcmdldDtcbiAgY29uc3QgcGFzc2l2ZSA9IHR5cGUgPT09ICd3aGVlbCcgPyBmYWxzZSA6IHVuZGVmaW5lZDtcbiAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlcnNbdHlwZV0sIHtwYXNzaXZlfSk7XG59XG5mdW5jdGlvbiBtb3VzZU1vdmUoY2hhcnQsIGV2ZW50KSB7XG4gIGNvbnN0IHN0YXRlID0gZ2V0U3RhdGUoY2hhcnQpO1xuICBpZiAoc3RhdGUuZHJhZ1N0YXJ0KSB7XG4gICAgc3RhdGUuZHJhZ2dpbmcgPSB0cnVlO1xuICAgIHN0YXRlLmRyYWdFbmQgPSBldmVudDtcbiAgICBjaGFydC51cGRhdGUoJ25vbmUnKTtcbiAgfVxufVxuZnVuY3Rpb24ga2V5RG93bihjaGFydCwgZXZlbnQpIHtcbiAgY29uc3Qgc3RhdGUgPSBnZXRTdGF0ZShjaGFydCk7XG4gIGlmICghc3RhdGUuZHJhZ1N0YXJ0IHx8IGV2ZW50LmtleSAhPT0gJ0VzY2FwZScpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcmVtb3ZlSGFuZGxlcihjaGFydCwgJ2tleWRvd24nKTtcbiAgc3RhdGUuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgc3RhdGUuZHJhZ1N0YXJ0ID0gc3RhdGUuZHJhZ0VuZCA9IG51bGw7XG4gIGNoYXJ0LnVwZGF0ZSgnbm9uZScpO1xufVxuZnVuY3Rpb24gZ2V0UG9pbnRQb3NpdGlvbihldmVudCwgY2hhcnQpIHtcbiAgY29uc3QgcG9pbnQgPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGV2ZW50LCBjaGFydCk7XG4gIGNvbnN0IGNhbnZhc0FyZWEgPSBjaGFydC5jYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGlmICghX2lzUG9pbnRJbkFyZWEoZXZlbnQsIGNhbnZhc0FyZWEpKSB7XG4gICAgcG9pbnQueCA9IGV2ZW50LmNsaWVudFggLSBjYW52YXNBcmVhLmxlZnQ7XG4gICAgcG9pbnQueSA9IGV2ZW50LmNsaWVudFkgLSBjYW52YXNBcmVhLnRvcDtcbiAgfVxuICByZXR1cm4gcG9pbnQ7XG59XG5mdW5jdGlvbiB6b29tU3RhcnQoY2hhcnQsIGV2ZW50LCB6b29tT3B0aW9ucykge1xuICBjb25zdCB7b25ab29tU3RhcnQsIG9uWm9vbVJlamVjdGVkfSA9IHpvb21PcHRpb25zO1xuICBpZiAob25ab29tU3RhcnQpIHtcbiAgICBjb25zdCBwb2ludCA9IGdldFBvaW50UG9zaXRpb24oZXZlbnQsIGNoYXJ0KTtcbiAgICBpZiAoY2FsbGJhY2sob25ab29tU3RhcnQsIFt7Y2hhcnQsIGV2ZW50LCBwb2ludH1dKSA9PT0gZmFsc2UpIHtcbiAgICAgIGNhbGxiYWNrKG9uWm9vbVJlamVjdGVkLCBbe2NoYXJ0LCBldmVudH1dKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1vdXNlRG93bihjaGFydCwgZXZlbnQpIHtcbiAgaWYgKGNoYXJ0LmxlZ2VuZCkge1xuICAgIGNvbnN0IHBvaW50ID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihldmVudCwgY2hhcnQpO1xuICAgIGlmIChfaXNQb2ludEluQXJlYShwb2ludCwgY2hhcnQubGVnZW5kKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBjb25zdCBzdGF0ZSA9IGdldFN0YXRlKGNoYXJ0KTtcbiAgY29uc3Qge3BhbjogcGFuT3B0aW9ucywgem9vbTogem9vbU9wdGlvbnMgPSB7fX0gPSBzdGF0ZS5vcHRpb25zO1xuICBpZiAoXG4gICAgZXZlbnQuYnV0dG9uICE9PSAwIHx8XG4gICAga2V5UHJlc3NlZChnZXRNb2RpZmllcktleShwYW5PcHRpb25zKSwgZXZlbnQpIHx8XG4gICAga2V5Tm90UHJlc3NlZChnZXRNb2RpZmllcktleSh6b29tT3B0aW9ucy5kcmFnKSwgZXZlbnQpXG4gICkge1xuICAgIHJldHVybiBjYWxsYmFjayh6b29tT3B0aW9ucy5vblpvb21SZWplY3RlZCwgW3tjaGFydCwgZXZlbnR9XSk7XG4gIH1cbiAgaWYgKHpvb21TdGFydChjaGFydCwgZXZlbnQsIHpvb21PcHRpb25zKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgc3RhdGUuZHJhZ1N0YXJ0ID0gZXZlbnQ7XG4gIGFkZEhhbmRsZXIoY2hhcnQsIGNoYXJ0LmNhbnZhcy5vd25lckRvY3VtZW50LCAnbW91c2Vtb3ZlJywgbW91c2VNb3ZlKTtcbiAgYWRkSGFuZGxlcihjaGFydCwgd2luZG93LmRvY3VtZW50LCAna2V5ZG93bicsIGtleURvd24pO1xufVxuZnVuY3Rpb24gYXBwbHlBc3BlY3RSYXRpbyhlbmRQb2ludCwgYmVnaW5Qb2ludCwgYXNwZWN0UmF0aW8pIHtcbiAgbGV0IHdpZHRoID0gZW5kUG9pbnQueCAtIGJlZ2luUG9pbnQueDtcbiAgbGV0IGhlaWdodCA9IGVuZFBvaW50LnkgLSBiZWdpblBvaW50Lnk7XG4gIGNvbnN0IHJhdGlvID0gTWF0aC5hYnMod2lkdGggLyBoZWlnaHQpO1xuICBpZiAocmF0aW8gPiBhc3BlY3RSYXRpbykge1xuICAgIHdpZHRoID0gTWF0aC5zaWduKHdpZHRoKSAqIE1hdGguYWJzKGhlaWdodCAqIGFzcGVjdFJhdGlvKTtcbiAgfSBlbHNlIGlmIChyYXRpbyA8IGFzcGVjdFJhdGlvKSB7XG4gICAgaGVpZ2h0ID0gTWF0aC5zaWduKGhlaWdodCkgKiBNYXRoLmFicyh3aWR0aCAvIGFzcGVjdFJhdGlvKTtcbiAgfVxuICBlbmRQb2ludC54ID0gYmVnaW5Qb2ludC54ICsgd2lkdGg7XG4gIGVuZFBvaW50LnkgPSBiZWdpblBvaW50LnkgKyBoZWlnaHQ7XG59XG5mdW5jdGlvbiBhcHBseU1pbk1heFByb3BzKHJlY3QsIGJlZ2luUG9pbnQsIGVuZFBvaW50LCB7bWluLCBtYXgsIHByb3B9KSB7XG4gIHJlY3RbbWluXSA9IE1hdGgubWF4KDAsIE1hdGgubWluKGJlZ2luUG9pbnRbcHJvcF0sIGVuZFBvaW50W3Byb3BdKSk7XG4gIHJlY3RbbWF4XSA9IE1hdGgubWF4KGJlZ2luUG9pbnRbcHJvcF0sIGVuZFBvaW50W3Byb3BdKTtcbn1cbmZ1bmN0aW9uIGdldFJlcGxhdGl2ZVBvaW50cyhjaGFydCwgcG9pbnRzLCBtYWludGFpbkFzcGVjdFJhdGlvKSB7XG4gIGNvbnN0IGJlZ2luUG9pbnQgPSBnZXRQb2ludFBvc2l0aW9uKHBvaW50cy5kcmFnU3RhcnQsIGNoYXJ0KTtcbiAgY29uc3QgZW5kUG9pbnQgPSBnZXRQb2ludFBvc2l0aW9uKHBvaW50cy5kcmFnRW5kLCBjaGFydCk7XG4gIGlmIChtYWludGFpbkFzcGVjdFJhdGlvKSB7XG4gICAgY29uc3QgYXNwZWN0UmF0aW8gPSBjaGFydC5jaGFydEFyZWEud2lkdGggLyBjaGFydC5jaGFydEFyZWEuaGVpZ2h0O1xuICAgIGFwcGx5QXNwZWN0UmF0aW8oZW5kUG9pbnQsIGJlZ2luUG9pbnQsIGFzcGVjdFJhdGlvKTtcbiAgfVxuICByZXR1cm4ge2JlZ2luUG9pbnQsIGVuZFBvaW50fTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVEcmFnUmVjdChjaGFydCwgbW9kZSwgcG9pbnRzLCBtYWludGFpbkFzcGVjdFJhdGlvKSB7XG4gIGNvbnN0IHhFbmFibGVkID0gZGlyZWN0aW9uRW5hYmxlZChtb2RlLCAneCcsIGNoYXJ0KTtcbiAgY29uc3QgeUVuYWJsZWQgPSBkaXJlY3Rpb25FbmFibGVkKG1vZGUsICd5JywgY2hhcnQpO1xuICBjb25zdCB7dG9wLCBsZWZ0LCByaWdodCwgYm90dG9tLCB3aWR0aDogY2hhcnRXaWR0aCwgaGVpZ2h0OiBjaGFydEhlaWdodH0gPSBjaGFydC5jaGFydEFyZWE7XG4gIGNvbnN0IHJlY3QgPSB7dG9wLCBsZWZ0LCByaWdodCwgYm90dG9tfTtcbiAgY29uc3Qge2JlZ2luUG9pbnQsIGVuZFBvaW50fSA9IGdldFJlcGxhdGl2ZVBvaW50cyhjaGFydCwgcG9pbnRzLCBtYWludGFpbkFzcGVjdFJhdGlvICYmIHhFbmFibGVkICYmIHlFbmFibGVkKTtcbiAgaWYgKHhFbmFibGVkKSB7XG4gICAgYXBwbHlNaW5NYXhQcm9wcyhyZWN0LCBiZWdpblBvaW50LCBlbmRQb2ludCwge21pbjogJ2xlZnQnLCBtYXg6ICdyaWdodCcsIHByb3A6ICd4J30pO1xuICB9XG4gIGlmICh5RW5hYmxlZCkge1xuICAgIGFwcGx5TWluTWF4UHJvcHMocmVjdCwgYmVnaW5Qb2ludCwgZW5kUG9pbnQsIHttaW46ICd0b3AnLCBtYXg6ICdib3R0b20nLCBwcm9wOiAneSd9KTtcbiAgfVxuICBjb25zdCB3aWR0aCA9IHJlY3QucmlnaHQgLSByZWN0LmxlZnQ7XG4gIGNvbnN0IGhlaWdodCA9IHJlY3QuYm90dG9tIC0gcmVjdC50b3A7XG4gIHJldHVybiB7XG4gICAgLi4ucmVjdCxcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgem9vbVg6IHhFbmFibGVkICYmIHdpZHRoID8gMSArICgoY2hhcnRXaWR0aCAtIHdpZHRoKSAvIGNoYXJ0V2lkdGgpIDogMSxcbiAgICB6b29tWTogeUVuYWJsZWQgJiYgaGVpZ2h0ID8gMSArICgoY2hhcnRIZWlnaHQgLSBoZWlnaHQpIC8gY2hhcnRIZWlnaHQpIDogMVxuICB9O1xufVxuZnVuY3Rpb24gbW91c2VVcChjaGFydCwgZXZlbnQpIHtcbiAgY29uc3Qgc3RhdGUgPSBnZXRTdGF0ZShjaGFydCk7XG4gIGlmICghc3RhdGUuZHJhZ1N0YXJ0KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJlbW92ZUhhbmRsZXIoY2hhcnQsICdtb3VzZW1vdmUnKTtcbiAgY29uc3Qge21vZGUsIG9uWm9vbUNvbXBsZXRlLCBkcmFnOiB7dGhyZXNob2xkID0gMCwgbWFpbnRhaW5Bc3BlY3RSYXRpb319ID0gc3RhdGUub3B0aW9ucy56b29tO1xuICBjb25zdCByZWN0ID0gY29tcHV0ZURyYWdSZWN0KGNoYXJ0LCBtb2RlLCB7ZHJhZ1N0YXJ0OiBzdGF0ZS5kcmFnU3RhcnQsIGRyYWdFbmQ6IGV2ZW50fSwgbWFpbnRhaW5Bc3BlY3RSYXRpbyk7XG4gIGNvbnN0IGRpc3RhbmNlWCA9IGRpcmVjdGlvbkVuYWJsZWQobW9kZSwgJ3gnLCBjaGFydCkgPyByZWN0LndpZHRoIDogMDtcbiAgY29uc3QgZGlzdGFuY2VZID0gZGlyZWN0aW9uRW5hYmxlZChtb2RlLCAneScsIGNoYXJ0KSA/IHJlY3QuaGVpZ2h0IDogMDtcbiAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZGlzdGFuY2VYICogZGlzdGFuY2VYICsgZGlzdGFuY2VZICogZGlzdGFuY2VZKTtcbiAgc3RhdGUuZHJhZ1N0YXJ0ID0gc3RhdGUuZHJhZ0VuZCA9IG51bGw7XG4gIGlmIChkaXN0YW5jZSA8PSB0aHJlc2hvbGQpIHtcbiAgICBzdGF0ZS5kcmFnZ2luZyA9IGZhbHNlO1xuICAgIGNoYXJ0LnVwZGF0ZSgnbm9uZScpO1xuICAgIHJldHVybjtcbiAgfVxuICB6b29tUmVjdChjaGFydCwge3g6IHJlY3QubGVmdCwgeTogcmVjdC50b3B9LCB7eDogcmVjdC5yaWdodCwgeTogcmVjdC5ib3R0b219LCAnem9vbScpO1xuICBzdGF0ZS5kcmFnZ2luZyA9IGZhbHNlO1xuICBzdGF0ZS5maWx0ZXJOZXh0Q2xpY2sgPSB0cnVlO1xuICBjYWxsYmFjayhvblpvb21Db21wbGV0ZSwgW3tjaGFydH1dKTtcbn1cbmZ1bmN0aW9uIHdoZWVsUHJlY29uZGl0aW9ucyhjaGFydCwgZXZlbnQsIHpvb21PcHRpb25zKSB7XG4gIGlmIChrZXlOb3RQcmVzc2VkKGdldE1vZGlmaWVyS2V5KHpvb21PcHRpb25zLndoZWVsKSwgZXZlbnQpKSB7XG4gICAgY2FsbGJhY2soem9vbU9wdGlvbnMub25ab29tUmVqZWN0ZWQsIFt7Y2hhcnQsIGV2ZW50fV0pO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoem9vbVN0YXJ0KGNoYXJ0LCBldmVudCwgem9vbU9wdGlvbnMpID09PSBmYWxzZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZXZlbnQuY2FuY2VsYWJsZSkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbiAgaWYgKGV2ZW50LmRlbHRhWSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gd2hlZWwoY2hhcnQsIGV2ZW50KSB7XG4gIGNvbnN0IHtoYW5kbGVyczoge29uWm9vbUNvbXBsZXRlfSwgb3B0aW9uczoge3pvb206IHpvb21PcHRpb25zfX0gPSBnZXRTdGF0ZShjaGFydCk7XG4gIGlmICghd2hlZWxQcmVjb25kaXRpb25zKGNoYXJ0LCBldmVudCwgem9vbU9wdGlvbnMpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHJlY3QgPSBldmVudC50YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGNvbnN0IHNwZWVkID0gem9vbU9wdGlvbnMud2hlZWwuc3BlZWQ7XG4gIGNvbnN0IHBlcmNlbnRhZ2UgPSBldmVudC5kZWx0YVkgPj0gMCA/IDIgLSAxIC8gKDEgLSBzcGVlZCkgOiAxICsgc3BlZWQ7XG4gIGNvbnN0IGFtb3VudCA9IHtcbiAgICB4OiBwZXJjZW50YWdlLFxuICAgIHk6IHBlcmNlbnRhZ2UsXG4gICAgZm9jYWxQb2ludDoge1xuICAgICAgeDogZXZlbnQuY2xpZW50WCAtIHJlY3QubGVmdCxcbiAgICAgIHk6IGV2ZW50LmNsaWVudFkgLSByZWN0LnRvcFxuICAgIH1cbiAgfTtcbiAgem9vbShjaGFydCwgYW1vdW50KTtcbiAgY2FsbGJhY2sob25ab29tQ29tcGxldGUsIFt7Y2hhcnR9XSk7XG59XG5mdW5jdGlvbiBhZGREZWJvdW5jZWRIYW5kbGVyKGNoYXJ0LCBuYW1lLCBoYW5kbGVyLCBkZWxheSkge1xuICBpZiAoaGFuZGxlcikge1xuICAgIGdldFN0YXRlKGNoYXJ0KS5oYW5kbGVyc1tuYW1lXSA9IGRlYm91bmNlKCgpID0+IGNhbGxiYWNrKGhhbmRsZXIsIFt7Y2hhcnR9XSksIGRlbGF5KTtcbiAgfVxufVxuZnVuY3Rpb24gYWRkTGlzdGVuZXJzKGNoYXJ0LCBvcHRpb25zKSB7XG4gIGNvbnN0IGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcbiAgY29uc3Qge3doZWVsOiB3aGVlbE9wdGlvbnMsIGRyYWc6IGRyYWdPcHRpb25zLCBvblpvb21Db21wbGV0ZX0gPSBvcHRpb25zLnpvb207XG4gIGlmICh3aGVlbE9wdGlvbnMuZW5hYmxlZCkge1xuICAgIGFkZEhhbmRsZXIoY2hhcnQsIGNhbnZhcywgJ3doZWVsJywgd2hlZWwpO1xuICAgIGFkZERlYm91bmNlZEhhbmRsZXIoY2hhcnQsICdvblpvb21Db21wbGV0ZScsIG9uWm9vbUNvbXBsZXRlLCAyNTApO1xuICB9IGVsc2Uge1xuICAgIHJlbW92ZUhhbmRsZXIoY2hhcnQsICd3aGVlbCcpO1xuICB9XG4gIGlmIChkcmFnT3B0aW9ucy5lbmFibGVkKSB7XG4gICAgYWRkSGFuZGxlcihjaGFydCwgY2FudmFzLCAnbW91c2Vkb3duJywgbW91c2VEb3duKTtcbiAgICBhZGRIYW5kbGVyKGNoYXJ0LCBjYW52YXMub3duZXJEb2N1bWVudCwgJ21vdXNldXAnLCBtb3VzZVVwKTtcbiAgfSBlbHNlIHtcbiAgICByZW1vdmVIYW5kbGVyKGNoYXJ0LCAnbW91c2Vkb3duJyk7XG4gICAgcmVtb3ZlSGFuZGxlcihjaGFydCwgJ21vdXNlbW92ZScpO1xuICAgIHJlbW92ZUhhbmRsZXIoY2hhcnQsICdtb3VzZXVwJyk7XG4gICAgcmVtb3ZlSGFuZGxlcihjaGFydCwgJ2tleWRvd24nKTtcbiAgfVxufVxuZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXJzKGNoYXJ0KSB7XG4gIHJlbW92ZUhhbmRsZXIoY2hhcnQsICdtb3VzZWRvd24nKTtcbiAgcmVtb3ZlSGFuZGxlcihjaGFydCwgJ21vdXNlbW92ZScpO1xuICByZW1vdmVIYW5kbGVyKGNoYXJ0LCAnbW91c2V1cCcpO1xuICByZW1vdmVIYW5kbGVyKGNoYXJ0LCAnd2hlZWwnKTtcbiAgcmVtb3ZlSGFuZGxlcihjaGFydCwgJ2NsaWNrJyk7XG4gIHJlbW92ZUhhbmRsZXIoY2hhcnQsICdrZXlkb3duJyk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVuYWJsZXIoY2hhcnQsIHN0YXRlKSB7XG4gIHJldHVybiBmdW5jdGlvbihyZWNvZ25pemVyLCBldmVudCkge1xuICAgIGNvbnN0IHtwYW46IHBhbk9wdGlvbnMsIHpvb206IHpvb21PcHRpb25zID0ge319ID0gc3RhdGUub3B0aW9ucztcbiAgICBpZiAoIXBhbk9wdGlvbnMgfHwgIXBhbk9wdGlvbnMuZW5hYmxlZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBzcmNFdmVudCA9IGV2ZW50ICYmIGV2ZW50LnNyY0V2ZW50O1xuICAgIGlmICghc3JjRXZlbnQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoIXN0YXRlLnBhbm5pbmcgJiYgZXZlbnQucG9pbnRlclR5cGUgPT09ICdtb3VzZScgJiYgKFxuICAgICAga2V5Tm90UHJlc3NlZChnZXRNb2RpZmllcktleShwYW5PcHRpb25zKSwgc3JjRXZlbnQpIHx8IGtleVByZXNzZWQoZ2V0TW9kaWZpZXJLZXkoem9vbU9wdGlvbnMuZHJhZyksIHNyY0V2ZW50KSlcbiAgICApIHtcbiAgICAgIGNhbGxiYWNrKHBhbk9wdGlvbnMub25QYW5SZWplY3RlZCwgW3tjaGFydCwgZXZlbnR9XSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xufVxuZnVuY3Rpb24gcGluY2hBeGVzKHAwLCBwMSkge1xuICBjb25zdCBwaW5jaFggPSBNYXRoLmFicyhwMC5jbGllbnRYIC0gcDEuY2xpZW50WCk7XG4gIGNvbnN0IHBpbmNoWSA9IE1hdGguYWJzKHAwLmNsaWVudFkgLSBwMS5jbGllbnRZKTtcbiAgY29uc3QgcCA9IHBpbmNoWCAvIHBpbmNoWTtcbiAgbGV0IHgsIHk7XG4gIGlmIChwID4gMC4zICYmIHAgPCAxLjcpIHtcbiAgICB4ID0geSA9IHRydWU7XG4gIH0gZWxzZSBpZiAocGluY2hYID4gcGluY2hZKSB7XG4gICAgeCA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgeSA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIHt4LCB5fTtcbn1cbmZ1bmN0aW9uIGhhbmRsZVBpbmNoKGNoYXJ0LCBzdGF0ZSwgZSkge1xuICBpZiAoc3RhdGUuc2NhbGUpIHtcbiAgICBjb25zdCB7Y2VudGVyLCBwb2ludGVyc30gPSBlO1xuICAgIGNvbnN0IHpvb21QZXJjZW50ID0gMSAvIHN0YXRlLnNjYWxlICogZS5zY2FsZTtcbiAgICBjb25zdCByZWN0ID0gZS50YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgcGluY2ggPSBwaW5jaEF4ZXMocG9pbnRlcnNbMF0sIHBvaW50ZXJzWzFdKTtcbiAgICBjb25zdCBtb2RlID0gc3RhdGUub3B0aW9ucy56b29tLm1vZGU7XG4gICAgY29uc3QgYW1vdW50ID0ge1xuICAgICAgeDogcGluY2gueCAmJiBkaXJlY3Rpb25FbmFibGVkKG1vZGUsICd4JywgY2hhcnQpID8gem9vbVBlcmNlbnQgOiAxLFxuICAgICAgeTogcGluY2gueSAmJiBkaXJlY3Rpb25FbmFibGVkKG1vZGUsICd5JywgY2hhcnQpID8gem9vbVBlcmNlbnQgOiAxLFxuICAgICAgZm9jYWxQb2ludDoge1xuICAgICAgICB4OiBjZW50ZXIueCAtIHJlY3QubGVmdCxcbiAgICAgICAgeTogY2VudGVyLnkgLSByZWN0LnRvcFxuICAgICAgfVxuICAgIH07XG4gICAgem9vbShjaGFydCwgYW1vdW50KTtcbiAgICBzdGF0ZS5zY2FsZSA9IGUuc2NhbGU7XG4gIH1cbn1cbmZ1bmN0aW9uIHN0YXJ0UGluY2goY2hhcnQsIHN0YXRlLCBldmVudCkge1xuICBpZiAoc3RhdGUub3B0aW9ucy56b29tLnBpbmNoLmVuYWJsZWQpIHtcbiAgICBjb25zdCBwb2ludCA9IGdldFJlbGF0aXZlUG9zaXRpb24oZXZlbnQsIGNoYXJ0KTtcbiAgICBjYWxsYmFjayhzdGF0ZS5vcHRpb25zLnpvb20ub25ab29tU3RhcnQsIFt7Y2hhcnQsIGV2ZW50LCBwb2ludH1dKTtcbiAgICBzdGF0ZS5zY2FsZSA9IDE7XG4gIH1cbn1cbmZ1bmN0aW9uIGVuZFBpbmNoKGNoYXJ0LCBzdGF0ZSwgZSkge1xuICBpZiAoc3RhdGUuc2NhbGUpIHtcbiAgICBoYW5kbGVQaW5jaChjaGFydCwgc3RhdGUsIGUpO1xuICAgIHN0YXRlLnNjYWxlID0gbnVsbDtcbiAgICBjYWxsYmFjayhzdGF0ZS5vcHRpb25zLnpvb20ub25ab29tQ29tcGxldGUsIFt7Y2hhcnR9XSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGhhbmRsZVBhbihjaGFydCwgc3RhdGUsIGUpIHtcbiAgY29uc3QgZGVsdGEgPSBzdGF0ZS5kZWx0YTtcbiAgaWYgKGRlbHRhKSB7XG4gICAgc3RhdGUucGFubmluZyA9IHRydWU7XG4gICAgcGFuKGNoYXJ0LCB7eDogZS5kZWx0YVggLSBkZWx0YS54LCB5OiBlLmRlbHRhWSAtIGRlbHRhLnl9LCBzdGF0ZS5wYW5TY2FsZXMpO1xuICAgIHN0YXRlLmRlbHRhID0ge3g6IGUuZGVsdGFYLCB5OiBlLmRlbHRhWX07XG4gIH1cbn1cbmZ1bmN0aW9uIHN0YXJ0UGFuKGNoYXJ0LCBzdGF0ZSwgZXZlbnQpIHtcbiAgY29uc3Qge2VuYWJsZWQsIG9uUGFuU3RhcnQsIG9uUGFuUmVqZWN0ZWR9ID0gc3RhdGUub3B0aW9ucy5wYW47XG4gIGlmICghZW5hYmxlZCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCByZWN0ID0gZXZlbnQudGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBjb25zdCBwb2ludCA9IHtcbiAgICB4OiBldmVudC5jZW50ZXIueCAtIHJlY3QubGVmdCxcbiAgICB5OiBldmVudC5jZW50ZXIueSAtIHJlY3QudG9wXG4gIH07XG4gIGlmIChjYWxsYmFjayhvblBhblN0YXJ0LCBbe2NoYXJ0LCBldmVudCwgcG9pbnR9XSkgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG9uUGFuUmVqZWN0ZWQsIFt7Y2hhcnQsIGV2ZW50fV0pO1xuICB9XG4gIHN0YXRlLnBhblNjYWxlcyA9IGdldEVuYWJsZWRTY2FsZXNCeVBvaW50KHN0YXRlLm9wdGlvbnMucGFuLCBwb2ludCwgY2hhcnQpO1xuICBzdGF0ZS5kZWx0YSA9IHt4OiAwLCB5OiAwfTtcbiAgaGFuZGxlUGFuKGNoYXJ0LCBzdGF0ZSwgZXZlbnQpO1xufVxuZnVuY3Rpb24gZW5kUGFuKGNoYXJ0LCBzdGF0ZSkge1xuICBzdGF0ZS5kZWx0YSA9IG51bGw7XG4gIGlmIChzdGF0ZS5wYW5uaW5nKSB7XG4gICAgc3RhdGUucGFubmluZyA9IGZhbHNlO1xuICAgIHN0YXRlLmZpbHRlck5leHRDbGljayA9IHRydWU7XG4gICAgY2FsbGJhY2soc3RhdGUub3B0aW9ucy5wYW4ub25QYW5Db21wbGV0ZSwgW3tjaGFydH1dKTtcbiAgfVxufVxuY29uc3QgaGFtbWVycyA9IG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBzdGFydEhhbW1lcihjaGFydCwgb3B0aW9ucykge1xuICBjb25zdCBzdGF0ZSA9IGdldFN0YXRlKGNoYXJ0KTtcbiAgY29uc3QgY2FudmFzID0gY2hhcnQuY2FudmFzO1xuICBjb25zdCB7cGFuOiBwYW5PcHRpb25zLCB6b29tOiB6b29tT3B0aW9uc30gPSBvcHRpb25zO1xuICBjb25zdCBtYyA9IG5ldyBIYW1tZXIuTWFuYWdlcihjYW52YXMpO1xuICBpZiAoem9vbU9wdGlvbnMgJiYgem9vbU9wdGlvbnMucGluY2guZW5hYmxlZCkge1xuICAgIG1jLmFkZChuZXcgSGFtbWVyLlBpbmNoKCkpO1xuICAgIG1jLm9uKCdwaW5jaHN0YXJ0JywgKGUpID0+IHN0YXJ0UGluY2goY2hhcnQsIHN0YXRlLCBlKSk7XG4gICAgbWMub24oJ3BpbmNoJywgKGUpID0+IGhhbmRsZVBpbmNoKGNoYXJ0LCBzdGF0ZSwgZSkpO1xuICAgIG1jLm9uKCdwaW5jaGVuZCcsIChlKSA9PiBlbmRQaW5jaChjaGFydCwgc3RhdGUsIGUpKTtcbiAgfVxuICBpZiAocGFuT3B0aW9ucyAmJiBwYW5PcHRpb25zLmVuYWJsZWQpIHtcbiAgICBtYy5hZGQobmV3IEhhbW1lci5QYW4oe1xuICAgICAgdGhyZXNob2xkOiBwYW5PcHRpb25zLnRocmVzaG9sZCxcbiAgICAgIGVuYWJsZTogY3JlYXRlRW5hYmxlcihjaGFydCwgc3RhdGUpXG4gICAgfSkpO1xuICAgIG1jLm9uKCdwYW5zdGFydCcsIChlKSA9PiBzdGFydFBhbihjaGFydCwgc3RhdGUsIGUpKTtcbiAgICBtYy5vbigncGFubW92ZScsIChlKSA9PiBoYW5kbGVQYW4oY2hhcnQsIHN0YXRlLCBlKSk7XG4gICAgbWMub24oJ3BhbmVuZCcsICgpID0+IGVuZFBhbihjaGFydCwgc3RhdGUpKTtcbiAgfVxuICBoYW1tZXJzLnNldChjaGFydCwgbWMpO1xufVxuZnVuY3Rpb24gc3RvcEhhbW1lcihjaGFydCkge1xuICBjb25zdCBtYyA9IGhhbW1lcnMuZ2V0KGNoYXJ0KTtcbiAgaWYgKG1jKSB7XG4gICAgbWMucmVtb3ZlKCdwaW5jaHN0YXJ0Jyk7XG4gICAgbWMucmVtb3ZlKCdwaW5jaCcpO1xuICAgIG1jLnJlbW92ZSgncGluY2hlbmQnKTtcbiAgICBtYy5yZW1vdmUoJ3BhbnN0YXJ0Jyk7XG4gICAgbWMucmVtb3ZlKCdwYW4nKTtcbiAgICBtYy5yZW1vdmUoJ3BhbmVuZCcpO1xuICAgIG1jLmRlc3Ryb3koKTtcbiAgICBoYW1tZXJzLmRlbGV0ZShjaGFydCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGhhbW1lck9wdGlvbnNDaGFuZ2VkKG9sZE9wdGlvbnMsIG5ld09wdGlvbnMpIHtcbiAgY29uc3Qge3Bhbjogb2xkUGFuLCB6b29tOiBvbGRab29tfSA9IG9sZE9wdGlvbnM7XG4gIGNvbnN0IHtwYW46IG5ld1Bhbiwgem9vbTogbmV3Wm9vbX0gPSBuZXdPcHRpb25zO1xuICBpZiAob2xkWm9vbT8uem9vbT8ucGluY2g/LmVuYWJsZWQgIT09IG5ld1pvb20/Lnpvb20/LnBpbmNoPy5lbmFibGVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKG9sZFBhbj8uZW5hYmxlZCAhPT0gbmV3UGFuPy5lbmFibGVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKG9sZFBhbj8udGhyZXNob2xkICE9PSBuZXdQYW4/LnRocmVzaG9sZCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIHZlcnNpb24gPSBcIjIuMS4wXCI7XG5cbmZ1bmN0aW9uIGRyYXcoY2hhcnQsIGNhbGxlciwgb3B0aW9ucykge1xuICBjb25zdCBkcmFnT3B0aW9ucyA9IG9wdGlvbnMuem9vbS5kcmFnO1xuICBjb25zdCB7ZHJhZ1N0YXJ0LCBkcmFnRW5kfSA9IGdldFN0YXRlKGNoYXJ0KTtcbiAgaWYgKGRyYWdPcHRpb25zLmRyYXdUaW1lICE9PSBjYWxsZXIgfHwgIWRyYWdFbmQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qge2xlZnQsIHRvcCwgd2lkdGgsIGhlaWdodH0gPSBjb21wdXRlRHJhZ1JlY3QoY2hhcnQsIG9wdGlvbnMuem9vbS5tb2RlLCB7ZHJhZ1N0YXJ0LCBkcmFnRW5kfSwgZHJhZ09wdGlvbnMubWFpbnRhaW5Bc3BlY3RSYXRpbyk7XG4gIGNvbnN0IGN0eCA9IGNoYXJ0LmN0eDtcbiAgY3R4LnNhdmUoKTtcbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBjdHguZmlsbFN0eWxlID0gZHJhZ09wdGlvbnMuYmFja2dyb3VuZENvbG9yIHx8ICdyZ2JhKDIyNSwyMjUsMjI1LDAuMyknO1xuICBjdHguZmlsbFJlY3QobGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KTtcbiAgaWYgKGRyYWdPcHRpb25zLmJvcmRlcldpZHRoID4gMCkge1xuICAgIGN0eC5saW5lV2lkdGggPSBkcmFnT3B0aW9ucy5ib3JkZXJXaWR0aDtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBkcmFnT3B0aW9ucy5ib3JkZXJDb2xvciB8fCAncmdiYSgyMjUsMjI1LDIyNSknO1xuICAgIGN0eC5zdHJva2VSZWN0KGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCk7XG4gIH1cbiAgY3R4LnJlc3RvcmUoKTtcbn1cbnZhciBwbHVnaW4gPSB7XG4gIGlkOiAnem9vbScsXG4gIHZlcnNpb24sXG4gIGRlZmF1bHRzOiB7XG4gICAgcGFuOiB7XG4gICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgIG1vZGU6ICd4eScsXG4gICAgICB0aHJlc2hvbGQ6IDEwLFxuICAgICAgbW9kaWZpZXJLZXk6IG51bGwsXG4gICAgfSxcbiAgICB6b29tOiB7XG4gICAgICB3aGVlbDoge1xuICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgc3BlZWQ6IDAuMSxcbiAgICAgICAgbW9kaWZpZXJLZXk6IG51bGxcbiAgICAgIH0sXG4gICAgICBkcmFnOiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBkcmF3VGltZTogJ2JlZm9yZURhdGFzZXRzRHJhdycsXG4gICAgICAgIG1vZGlmaWVyS2V5OiBudWxsXG4gICAgICB9LFxuICAgICAgcGluY2g6IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2VcbiAgICAgIH0sXG4gICAgICBtb2RlOiAneHknLFxuICAgIH1cbiAgfSxcbiAgc3RhcnQ6IGZ1bmN0aW9uKGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IHN0YXRlID0gZ2V0U3RhdGUoY2hhcnQpO1xuICAgIHN0YXRlLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucy56b29tLCAnZW5hYmxlZCcpKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1RoZSBvcHRpb24gYHpvb20uZW5hYmxlZGAgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZC4gUGxlYXNlIHVzZSBgem9vbS53aGVlbC5lbmFibGVkYCwgYHpvb20uZHJhZy5lbmFibGVkYCwgb3IgYHpvb20ucGluY2guZW5hYmxlZGAuJyk7XG4gICAgfVxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucy56b29tLCAnb3ZlclNjYWxlTW9kZScpXG4gICAgICB8fCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucy5wYW4sICdvdmVyU2NhbGVNb2RlJykpIHtcbiAgICAgIGNvbnNvbGUud2FybignVGhlIG9wdGlvbiBgb3ZlclNjYWxlTW9kZWAgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBgc2NhbGVNb2RlYCBpbnN0ZWFkIChhbmQgdXBkYXRlIGBtb2RlYCBhcyBkZXNpcmVkKS4nKTtcbiAgICB9XG4gICAgaWYgKEhhbW1lcikge1xuICAgICAgc3RhcnRIYW1tZXIoY2hhcnQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjaGFydC5wYW4gPSAoZGVsdGEsIHBhblNjYWxlcywgdHJhbnNpdGlvbikgPT4gcGFuKGNoYXJ0LCBkZWx0YSwgcGFuU2NhbGVzLCB0cmFuc2l0aW9uKTtcbiAgICBjaGFydC56b29tID0gKGFyZ3MsIHRyYW5zaXRpb24pID0+IHpvb20oY2hhcnQsIGFyZ3MsIHRyYW5zaXRpb24pO1xuICAgIGNoYXJ0Lnpvb21SZWN0ID0gKHAwLCBwMSwgdHJhbnNpdGlvbikgPT4gem9vbVJlY3QoY2hhcnQsIHAwLCBwMSwgdHJhbnNpdGlvbik7XG4gICAgY2hhcnQuem9vbVNjYWxlID0gKGlkLCByYW5nZSwgdHJhbnNpdGlvbikgPT4gem9vbVNjYWxlKGNoYXJ0LCBpZCwgcmFuZ2UsIHRyYW5zaXRpb24pO1xuICAgIGNoYXJ0LnJlc2V0Wm9vbSA9ICh0cmFuc2l0aW9uKSA9PiByZXNldFpvb20oY2hhcnQsIHRyYW5zaXRpb24pO1xuICAgIGNoYXJ0LmdldFpvb21MZXZlbCA9ICgpID0+IGdldFpvb21MZXZlbChjaGFydCk7XG4gICAgY2hhcnQuZ2V0SW5pdGlhbFNjYWxlQm91bmRzID0gKCkgPT4gZ2V0SW5pdGlhbFNjYWxlQm91bmRzKGNoYXJ0KTtcbiAgICBjaGFydC5nZXRab29tZWRTY2FsZUJvdW5kcyA9ICgpID0+IGdldFpvb21lZFNjYWxlQm91bmRzKGNoYXJ0KTtcbiAgICBjaGFydC5pc1pvb21lZE9yUGFubmVkID0gKCkgPT4gaXNab29tZWRPclBhbm5lZChjaGFydCk7XG4gICAgY2hhcnQuaXNab29taW5nT3JQYW5uaW5nID0gKCkgPT4gaXNab29taW5nT3JQYW5uaW5nKGNoYXJ0KTtcbiAgfSxcbiAgYmVmb3JlRXZlbnQoY2hhcnQsIHtldmVudH0pIHtcbiAgICBpZiAoaXNab29taW5nT3JQYW5uaW5nKGNoYXJ0KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2NsaWNrJyB8fCBldmVudC50eXBlID09PSAnbW91c2V1cCcpIHtcbiAgICAgIGNvbnN0IHN0YXRlID0gZ2V0U3RhdGUoY2hhcnQpO1xuICAgICAgaWYgKHN0YXRlLmZpbHRlck5leHRDbGljaykge1xuICAgICAgICBzdGF0ZS5maWx0ZXJOZXh0Q2xpY2sgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgYmVmb3JlVXBkYXRlOiBmdW5jdGlvbihjaGFydCwgYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IHN0YXRlID0gZ2V0U3RhdGUoY2hhcnQpO1xuICAgIGNvbnN0IHByZXZpb3VzT3B0aW9ucyA9IHN0YXRlLm9wdGlvbnM7XG4gICAgc3RhdGUub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgaWYgKGhhbW1lck9wdGlvbnNDaGFuZ2VkKHByZXZpb3VzT3B0aW9ucywgb3B0aW9ucykpIHtcbiAgICAgIHN0b3BIYW1tZXIoY2hhcnQpO1xuICAgICAgc3RhcnRIYW1tZXIoY2hhcnQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhZGRMaXN0ZW5lcnMoY2hhcnQsIG9wdGlvbnMpO1xuICB9LFxuICBiZWZvcmVEYXRhc2V0c0RyYXcoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgZHJhdyhjaGFydCwgJ2JlZm9yZURhdGFzZXRzRHJhdycsIG9wdGlvbnMpO1xuICB9LFxuICBhZnRlckRhdGFzZXRzRHJhdyhjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBkcmF3KGNoYXJ0LCAnYWZ0ZXJEYXRhc2V0c0RyYXcnLCBvcHRpb25zKTtcbiAgfSxcbiAgYmVmb3JlRHJhdyhjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBkcmF3KGNoYXJ0LCAnYmVmb3JlRHJhdycsIG9wdGlvbnMpO1xuICB9LFxuICBhZnRlckRyYXcoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgZHJhdyhjaGFydCwgJ2FmdGVyRHJhdycsIG9wdGlvbnMpO1xuICB9LFxuICBzdG9wOiBmdW5jdGlvbihjaGFydCkge1xuICAgIHJlbW92ZUxpc3RlbmVycyhjaGFydCk7XG4gICAgaWYgKEhhbW1lcikge1xuICAgICAgc3RvcEhhbW1lcihjaGFydCk7XG4gICAgfVxuICAgIHJlbW92ZVN0YXRlKGNoYXJ0KTtcbiAgfSxcbiAgcGFuRnVuY3Rpb25zLFxuICB6b29tRnVuY3Rpb25zLFxuICB6b29tUmVjdEZ1bmN0aW9ucyxcbn07XG5cbmV4cG9ydCB7IHBsdWdpbiBhcyBkZWZhdWx0LCBwYW4sIHJlc2V0Wm9vbSwgem9vbSwgem9vbVJlY3QsIHpvb21TY2FsZSB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/chartjs-plugin-zoom/dist/chartjs-plugin-zoom.esm.js\n");

/***/ })

};
;